/*
Path manipulation functions.

The "normalizeArray" and "Canonicalize" functions
are based on NodeJS's ./lib/path.js file, which has the following copyright notice:

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

Other functions added by Assaf Gordon, under same license as above.

NOTES:
1.	basename("/") -> returns "" in original NodeJS,
		         but "/" on GNU Coreutils (and in this module).

        path.basename('foo.txt','foo.txt')  === "" : incorrect according to POSIX.

2. canonicalize() -
    similar to NodeJS's path.resolve(), except
    if given relative path, does not resolve to absolute path,
    and accepts only one parameter.

*/

"use strict";

var str_utils = require('utils/string_utils');

module.exports = new path_utils(); //NOTE: a singleton, not a class

function path_utils() {

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

  // posix version
  function isAbsolute(path) {
    return path.charAt(0) === '/';
  };


  function canonicalize(path) {
    var isAbs = isAbsolute(path),
        trailingSlash = path[path.length - 1] === '/',
        segments = path.split('/'),
        nonEmptySegments = [];

    // Normalize the path
    for (var i = 0; i < segments.length; i++) {
      if (segments[i]) {
        nonEmptySegments.push(segments[i]);
      }
    }
    path = normalizeArray(nonEmptySegments, !isAbs).join('/');

    if (!path && !isAbs) {
      path = '.';
    }
    /*
 if (path && trailingSlash) {
      path += '/';
    }*/

    return (isAbs ? '/' : '') + path;
  };


function resolve(cwd_abs_path, new_path)
{
	if (!isAbsolute(cwd_abs_path))
		throw new Error("resolve: cwd_abs_path is not absolute path: '" + cwd_abs_path + "'");

	new_path = canonicalize(new_path);
	if (isAbsolute(new_path))
		return new_path;

	var path = canonicalize(cwd_abs_path + '/' + new_path);
	return path;
}



/*
POSIX Basename(3)
http://pubs.opengroup.org/onlinepubs/009604499/functions/basename.html

POSIX Basename(1)
http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html
*/
function basename(path, suffix)
{
	// Case #1 - empty string
	if (path === null || path === undefined || path === "") {
		return ".";
	}

	// Case #2 and #3 - string of all slashes
	if (str_utils.firstNotOf(path,'/')===-1)
		return "/";

	// Case #4 - remove trailing slash
	while (path[path.length - 1] === '/') {
		path = path.slice(0,-1);
	}

	// Case #5 - remove any prefix upto the last slash
	var i = path.lastIndexOf('/');
	if (i !== -1)
		path = path.slice(i+1);

	// case #6 - suffix
	if ((suffix !== undefined) &&
	    (suffix !== null) &&
	    (suffix.length>0) &&
	    (suffix !== path) &&
	    (path.slice(-suffix.length)===suffix))
		path = path.slice(0,-suffix.length);

	return path;
};

/*
POSIX dirname(1)
http://pubs.opengroup.org/onlinepubs/009695299/utilities/dirname.html

POSIX dirname(3)
http://pubs.opengroup.org/onlinepubs/009604499/functions/dirname.html
*/
function dirname(path) {
	if (path === undefined ||
	    path === null ||
	    path.length === 0)
		return ".";

	// case #1
	if (path === "//")
		return path;

	// Case #2 - all slashes
	if (str_utils.firstNotOf(path,'/')===-1)
		return "/";

	// Case #3 - remove trailing slash
	while (path[path.length - 1] === '/') {
		path = path.slice(0,-1);
	}

	// Case #4 - no remaining slashes
	if (path.indexOf('/')===-1)
		return '.';

	// Case #5 - remove trailing non-slashes
	while (path[path.length - 1] !== '/') {
		path = path.slice(0,-1);
	}

	// Case #7 - remove trailing slash
	while (path[path.length - 1] === '/') {
		path = path.slice(0,-1);
	}

	// Case #8
	if (path.length===0)
		return "/";

	return path;
};

function filemode_to_string(mode)
{
	var result = "";

	//user
	result += (mode&0x100)?'r':'-';
	result += (mode&0x080)?'w':'-';
	result += (mode&0x040)?'x':'-';
	//group
	result += (mode&0x020)?'r':'-';
	result += (mode&0x010)?'w':'-';
	result += (mode&0x008)?'x':'-';
	//other
	result += (mode&0x004)?'r':'-';
	result += (mode&0x002)?'w':'-';
	result += (mode&0x001)?'x':'-';

	return result;
}

//NOTE:
//This is tightly-coupled with 'os/storage_object'
function filetype_to_string(type)
{
	switch(type)
	{
	case "file":
		return '-';
	case "directory":
		return 'd';
	default:
		return '?';
	}
}

// Akin to fnmatch(3) - WITHOUT any flags.
// Retuns a javascript RegExp.exec() results, or NULL .
function __fnmatch_exec(pattern,string,
		anchor_start,
		anchor_end,
		greedy)
{
	//Convert shell matching pattern to to JS Regex
	// For bracket expansion, see also convert_bracket_char_class().

	/* There are several subtle incompatabilities (or mis-implemented conversions).
           Example, this is valid shell command, which will match a file
           named 'a-c].txt':
              ls a-c]*
           But converting it to valid Javascript regex will fail
           with 'unmatched bracket'. */
	var fix_pattern = (greedy)
		?str_utils.regex_fnmatch_longest_to_JS(pattern)
		:str_utils.regex_fnmatch_shortest_to_JS(pattern);

	if (anchor_start)
		fix_pattern = '^' + fix_pattern;

/* A Hack to force the RegExp engine to match non-greedy AND the end (left side)
   of the string. Since matching always starts from the beginning (right) of
   the string, if we don't give en RegExp engine an additional '.*' to greedly
   match the beginning, it won't match non-greedily our pattern.

   Compare:

   # The result is greedy, despite using '?'
   $ echo helloooooowold | perl -lne 'm/(o.*?$)/ && print $1'
   oooooowold

   # Now it's non-greedy, because the first '.*' consumed most of the text.
   $ echo helloooooowold | perl -lne 'm/.*(o.*?$)/ && print $1'
   old
*/
	if (anchor_end && !greedy)
		fix_pattern = '.*(' + fix_pattern +')';
	if (anchor_end)
		fix_pattern += '$';

	var re = new RegExp( fix_pattern );
	var r = re.exec(string);

	if (1) {
	console.log("string  = '" + string + "'");
	console.log("pattern = '" + pattern + "'");
	console.log("fix_pattern = '" + fix_pattern + "'");
	console.log("match = ", JSON.stringify(r,undefined,2));
	}

    if ( r === null )
        return null;

	var pos = r.index;
	var len = r[0].length;
	var str = r[0];
	/* See hack note above. If it's suffix+non-greedy, the regex
           had a groupping, so use index 1 instead of 0 */
	if (anchor_end && !greedy){
		len = r[1].length;
		str = r[1];
		pos = string.length - len;
	}

	return { "pos": pos, "len" : len, "str": str } ;
}

// Akin to fnmatch(3) - WITHOUT any flags.
// returns TRUE or FALSE .
function __fnmatch_test(pattern,string,
		anchor_start,
		anchor_end,
		greedy)
{
	return __fnmatch_exec(pattern,string,
		anchor_start,anchor_end,greedy) !== null;
}


this.dirname  = dirname;
this.basename = basename;
this.canonicalize = canonicalize;
this.isAbsolute = isAbsolute;
this.filetype_to_string = filetype_to_string;
this.filemode_to_string = filemode_to_string;
this.resolve = resolve;
this.__fnmatch_exec = __fnmatch_exec;
this.__fnmatch_test = __fnmatch_test;

}
