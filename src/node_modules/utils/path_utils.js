/*
Path manipulation functions.

The "normalizeArray" and "Canonicalize" functions
are based on NodeJS's ./lib/path.js file, which has the following copyright notice:

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

Other functions added by Assaf Gordon, under same license as above.

NOTES:
1.	basename("/") -> returns "" in original NodeJS,
		         but "/" on GNU Coreutils (and in this module).

        path.basename('foo.txt','foo.txt')  === "" : incorrect according to POSIX.

2. canonicalize() -
    similar to NodeJS's path.resolve(), except
    if given relative path, does not resolve to absolute path,
    and accepts only one parameter.

*/

"use strict";

var str_utils = require('utils/string_utils');

module.exports = new path_utils(); //NOTE: a singleton, not a class

function path_utils() {

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

  // posix version
  function isAbsolute(path) {
    return path.charAt(0) === '/';
  };


  function canonicalize(path) {
    var isAbs = isAbsolute(path),
        trailingSlash = path[path.length - 1] === '/',
        segments = path.split('/'),
        nonEmptySegments = [];

    // Normalize the path
    for (var i = 0; i < segments.length; i++) {
      if (segments[i]) {
        nonEmptySegments.push(segments[i]);
      }
    }
    path = normalizeArray(nonEmptySegments, !isAbs).join('/');

    if (!path && !isAbs) {
      path = '.';
    }
    /*
 if (path && trailingSlash) {
      path += '/';
    }*/

    return (isAbs ? '/' : '') + path;
  };


function resolve(cwd_abs_path, new_path)
{
	if (!isAbsolute(cwd_abs_path))
		throw new Error("resolve: cwd_abs_path is not absolute path: '" + cwd_abs_path + "'");

	new_path = canonicalize(new_path);
	if (isAbsolute(new_path))
		return new_path;

	var path = canonicalize(cwd_abs_path + '/' + new_path);
	return path;
}



/*
POSIX Basename(3)
http://pubs.opengroup.org/onlinepubs/009604499/functions/basename.html

POSIX Basename(1)
http://pubs.opengroup.org/onlinepubs/9699919799/utilities/basename.html
*/
function basename(path, suffix)
{
	// Case #1 - empty string
	if (path === null || path === undefined || path === "") {
		return ".";
	}

	// Case #2 and #3 - string of all slashes
	if (str_utils.firstNotOf(path,'/')===-1)
		return "/";

	// Case #4 - remove trailing slash
	while (path[path.length - 1] === '/') {
		path = path.slice(0,-1);
	}

	// Case #5 - remove any prefix upto the last slash
	var i = path.lastIndexOf('/');
	if (i !== -1)
		path = path.slice(i+1);

	// case #6 - suffix
	if ((suffix !== undefined) &&
	    (suffix !== null) &&
	    (suffix.length>0) &&
	    (suffix !== path) &&
	    (path.slice(-suffix.length)===suffix))
		path = path.slice(0,-suffix.length);

	return path;
};

/*
POSIX dirname(1)
http://pubs.opengroup.org/onlinepubs/009695299/utilities/dirname.html

POSIX dirname(3)
http://pubs.opengroup.org/onlinepubs/009604499/functions/dirname.html
*/
function dirname(path) {
	if (path === undefined ||
	    path === null ||
	    path.length === 0)
		return ".";

	// case #1
	if (path === "//")
		return path;

	// Case #2 - all slashes
	if (str_utils.firstNotOf(path,'/')===-1)
		return "/";

	// Case #3 - remove trailing slash
	while (path[path.length - 1] === '/') {
		path = path.slice(0,-1);
	}

	// Case #4 - no remaining slashes
	if (path.indexOf('/')===-1)
		return '.';

	// Case #5 - remove trailing non-slashes
	while (path[path.length - 1] !== '/') {
		path = path.slice(0,-1);
	}

	// Case #7 - remove trailing slash
	while (path[path.length - 1] === '/') {
		path = path.slice(0,-1);
	}

	// Case #8
	if (path.length===0)
		return "/";

	return path;
};

function filemode_to_string(mode)
{
	var result = "";

	//user
	result += (mode&0x100)?'r':'-';
	result += (mode&0x080)?'w':'-';
	result += (mode&0x040)?'x':'-';
	//group
	result += (mode&0x020)?'r':'-';
	result += (mode&0x010)?'w':'-';
	result += (mode&0x008)?'x':'-';
	//other
	result += (mode&0x004)?'r':'-';
	result += (mode&0x002)?'w':'-';
	result += (mode&0x001)?'x':'-';

	return result;
}

//NOTE:
//This is tightly-coupled with 'os/storage_object'
function filetype_to_string(type)
{
	switch(type)
	{
	case "file":
		return '-';
	case "directory":
		return 'd';
	default:
		return '?';
	}
}

// Akin to fnmatch(3) - WITHOUT any flags.
function __fnmatch(pattern,string,
		anchor_start,
		anchor_end,
		greedy)
{
	//Convert shell matching pattern to to JS Regex
	// For bracket expansion, see also convert_bracket_char_class().
	//TODO:
	//This is terribly inefficient. JS has no "replace all"?
	pattern = pattern
			.replace( /[().{}$^\\+]/g ,"\\$&")
			.replace( /\[:alnum:\]/g, '[A-Za-z0-9]')
			.replace( /\[:alpha:]/g, '[A-Za-z]')
			.replace( /\[:blank:]/g, '[ \t]')
			.replace( /\[:ctrl:]/g, '[\x00-\x20\x7f]')
			.replace( /\[:digit:]/g, '[0-9]')
			.replace( /\[:graph:]/g, '[\x21-\x7e]')
			.replace( /\[:lower:]/g, '[a-z]')
			.replace( /\[:print:]/g, '[\x20-\x7e]')
			.replace( /\[:punct:]/g, '[!"#$%&\'()*+,-./:)<=>?@[\\]^_`{|}~]')
			.replace( /\[:space:]/g, '[ \v\f\t\n\r]')
			.replace( /\[:upper:]/g, '[A-Z]')
			.replace( /\[:xdigit:]/g, '[A-Fa-f0-9]')
			.replace( /\?/g,'.')
			.replace( /\*/g, ( greedy ? '.*' : '.*?' ));

	if (anchor_start)
		pattern = '^' + pattern;
	if (anchor_end)
		pattern += '$';

	var re = new RegExp(pattern);
	var r = re.test(string);
console.log("string  = '" + string + "'");
console.log("pattern = '" + pattern + "'");
console.log("match = ", r);

	return r;
}


this.dirname  = dirname;
this.basename = basename;
this.canonicalize = canonicalize;
this.isAbsolute = isAbsolute;
this.filetype_to_string = filetype_to_string;
this.filemode_to_string = filemode_to_string;
this.resolve = resolve;
this.__fnmatch = __fnmatch;

}
