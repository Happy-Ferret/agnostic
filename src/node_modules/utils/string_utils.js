/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html
*/
"use strict";

/*
String-related Helper Functions


TODO:
1. Replace with UnderscoreJS ?

*/

module.exports = new string_utils(); //NOTE: a singleton, not a class


function string_utils()
{
/*
implementation of 'startsWith' and 'endsWith' from here:
http://stackoverflow.com/questions/646628/how-to-check-if-a-string-startswith-another-string
*/
	this.startsWith = function(str,prefix)
	{
		if (prefix.length===0) return true;
	        return str.slice(0, prefix.length) == prefix;
	}

	this.endsWith = function(str,suffix)
	{
	        if (suffix.length===0) return true;
		return str.slice(-suffix.length) == suffix;
	}

	this.trimWhitespace = function(str)
	{
		var tmp = str.replace(/[ \t]+$/,"");
		tmp = tmp.replace(/^[ \t]+/,"");
		return tmp;
	}

/*
Shell-Quoting related functions

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/


/*
Performs Field-Splitting on a string, respecting shell-quoting rules.

See Section "2.6 Word Expansions", Item 2,
and Section "2.6.5 Field Splitting".

NOTES:
1. IFS is always assumed to be SPACE+TAB+NEWLINE
2. Quotes (single/double) are NOT REMOVED
   (per the standard, quotes removal is always last)
3. Dollar sign has NO special meaning
   (it is assume. per the standard, the parameter/subshell/arithmetic/etc. expansion already occured)
*/
this.splitShellquotes = function(text) {

	/* Trim leading/trailing whitepace */
	text = text.replace(/[ \t\n]+$/,"");
	text = text.replace(/^[ \t\n]+/,"");
	var fields = [];

	var chars = text.split("");
	var current = "" ;
	var in_quotes = null;
	while ( chars.length>0 ) {
		var ch = chars.shift();
		switch (ch)
		{
		case ' ':
		case '\t':
		case '\n':
			if (in_quotes === null) {
				// Terminate current field, start a new one
				if (current !== "")
					fields.push(current);
				current = "";
				continue;
			}
			break;

		case '"':
			if (in_quotes === null) {
				//Start Double quote
				in_quotes = '"';
			} else if (in_quotes === '"') {
				//End double quotes
				in_quotes = null;
			} else {
				// single-quotes inside double quotes - no special action.
			}
			break;

		case "'":
			if (in_quotes === null) {
				//Start Single quote
				in_quotes = "'";
			} else if (in_quotes === "'") {
				//End Single quotes
				in_quotes = null;
			} else {
				// Double-quotes inside double quotes - no special action.
			}
			break;

		case '\\':
			// Back-slash
			// TODO: handle backslash+double-quotes inside double-quotes.
			break;
		}

		// Add character to the current field
		current += ch ;
	}
	if (current !== "")
		fields.push(current);

	if (in_quotes !== null)
		throw new Error("ShellQuotesSplit: unbalanced quotes in string (" + text + ")");

	return fields;
}


/*
Remove Quotes from a string, according to section "2.6.7 Quote Removal":
      "The quote characters: '\', '", and '' (backslash, single-quote,
       double-quote) that were present in the original word shall be removed
       unless they have themselves been quoted."
*/
this.removeShellquotes = function(text) {
	var result = "" ;
	var chars = text.split("");
	var in_quotes = null;
	while ( chars.length>0 ) {
		var ch = chars.shift();

		if ( ch === "'" || ch === '"' ) {
			if (in_quotes === null) {
				// Start new quotes
				in_quotes = ch;
				continue ;
			} else if (in_quotes === ch) {
				// End quotes
				in_quotes = null ;
				continue ;
			} else {
				//Quoted-quotes, add as valid caharacter
			}
		}

		// TODO: handle backslash

		// Add character to the current field
		result += ch ;
	}

	if (in_quotes !== null)
		throw new Error("ShellQuotesSplit: unbalanced quotes in string (" + text + ")");
	return result;
}


/*
Replace backslash characters with their equivalent
 e.g.:
    unbackslash("\\n") === "\n"
    unbackslash("\\t") === "\t"
    unbackslash("\\\\") === "\\"
    unbackslash("\\\\") === "\\"
*/
this.unbackslash = function(text) {
	var result = "" ;
	var chars = text.split("");
	while ( chars.length>0 ) {
		var ch = chars.shift();
		if ( (ch === "\\") && (chars.length>0) ) {
			ch = chars.shift();
			switch (ch)
			{
			case 't': ch = '\t'; break;
			case 'n': ch = '\n'; break;
			}
		}
		result += ch ;
	}
	return result;
}

/*
Similar to STL's string::find_first_not_of() .

Returns the index position in the 'text' string (0 = first character),
which has a character which is not equal to 'ch',
or -1 if no such character was found.

  firstNotOf("aaaBBccc",'a') === 3
  firstNotOf("aaaaaa",'b') === -1


*/
this.firstNotOf = function(text,ch) {
	if (ch.length !== 1)
		throw new TypeError('firstNotOf: ch parameter must be one character');
	for (var i = 0 ; i < text.length; i++) {
		if (text.charAt(i) !== ch)
			return i;
	}
	return -1;
}


function valid_varname(text) {
	return /^[A-Za-z_][A-Za-z_0-9]*$/.test(text);
}
this.valid_varname = valid_varname;

/*
Helper function for common shell action:
parsing a string with a variable name and possible assignment.
Examples:
	FOO
	FOO=
	FOO=BAR

Returns an object with four keys:
	name:   name of the variable
	value:  value of the variable, or undefined
	assignment: TRUE or FALSE, if there was an equal sign (implying an assignment).
	valid:  TRUE or FALSE, if 'name' is a valid shell variable name.
*/
this.parse_var_assignment = function(text)
{
	var varname, value, assignment, valid_identifier;

	// Check if there's assignment
	var idx = text.indexOf("=");
	if (idx !== -1) {
		assignment = true ;
		varname = text.slice(0,idx);
		value = text.slice(idx+1);
	} else {
		assignment = false;
		varname = text ;
	}
	valid_identifier = valid_varname(varname);

	return {
			name: varname,
			value: value,
			assignment: assignment,
			valid: valid_identifier
		};
}

/* Javascript strangeness:
    a = /[]/     => is valid ?
    doesn't allow character classess (e.g. '[:alnum:]')
    allow position/negative lookahead (?=p) (?:p)


    TODO:
	Prevent (by escaping) non-greedy expression,
	which are meaningless in ERE but meaningful in Javascript
*/

function __convert_regex_POSIX_to_JS(text,type)
{
	var chars = text.split('');

	var convert_regex_char;
	var convert_regex_backlash_char;

	if (type === "BRE") {
		convert_regex_char = convert_BRE_char ;
		convert_regex_backlash_char = convert_BRE_backslash_char ;
	} else if (type === "ERE") {
		convert_regex_char = function(ch) {return ch;} ;
		convert_regex_backlash_char = convert_ERE_backslash_char ;
	} else if (type === "fnmatch_longest") {
		convert_regex_char = convert_FNMATCH_greedy_char;
		convert_regex_backlash_char = convert_FNMATCH_char ;
	} else if (type === "fnmatch_shortest") {
		convert_regex_char = convert_FNMATCH_nongreedy_char;
		convert_regex_backlash_char = convert_FNMATCH_char ;
	} else {
		debugger;
		throw new Error("internal error");
	}

    function convert_FNMATCH_greedy_char(ch)
    {
        return convert_FNMATCH_char(ch, true);
    }

    function convert_FNMATCH_nongreedy_char(ch)
    {
        return convert_FNMATCH_char(ch, false);
    }

	// Convert (if needed) characters with special meaning in fnmatch(3)
	function convert_FNMATCH_char(ch,greedy)
	{
		switch (ch)
		{
		// These characters have no special meaning in FNMATCH,
		// but do have special meaning in Javascript's RegExp - so escape them.
		case '+':
		case '.':
		case '$':
		case '^':
		case '|':
		case '{':
		case '}':
		case '(':
		case ')':
            return '\\' + ch;

        //in fnmatch(3) syntax, '?' means a single character.
        //convert it to Javascript regexp synatx.
		case '?':
            return '.';

        //in fnmatch(3) syntax, '*' means zero or more characters.
        //convert it to Javascript regexp synatx.
        case '*':
            return (greedy?'.*':'.*?');

		default:
			return ch;
		}
	}

	// Convert (if needed) characters which in BRE are NOT-escaped.
	function convert_BRE_char(ch)
	{
		switch (ch)
		{
		// These characters have no special meaning in BRE,
		// but do have special meaning in Javascript's RegExp - so escape them.
		case '+':
		case '?':
		case '|':
		case '{':
		case '}':
		case '(':
		case ')':
			return '\\' + ch;
		default:
			return ch;
		}
	}

	// Convert (if needed) backslash characters which in BRE backslash-escaped
	function convert_BRE_backslash_char(ch)
	{
		if (ch[0] !== '\\')
			throw new Error('internal error');
		if (ch.length<2)
			throw new Error('internal error');

		// in BRE, these have special meaning when backslash-escaped.
		// In Javascript's RegExp, the meaning is reversed - so remove the backslash
		//   \(
		//   \)
		//   \{
		//   \}
		//   \?
		//   \\|
		var tmp = ch[1];
		if (tmp == '|' || tmp == '?' || tmp === '(' ||
			tmp === ')' || tmp ==='}' || tmp ==='{')
			return tmp;

		// In BRE, backslash-character have no special meaning
		// (officially: undefined meaning, but GNU grep treats '\d' as 'd' when in BRE).
		// But in Javascript, these DO have special meaning. so double-escape them.
		// e.g.
		//   echo d | grep '\d'   => prints 'd'
		if ( (tmp >= 'a' && tmp <= 'z') || ( tmp>='A' && tmp <='Z'))
			return '\\\\' + tmp;

		// Otherwise, return as is.
		// (e.g. for "\1", but also other undefined tokens)
		return ch;
	}

	// Convert (if needed) backslash characters which in ERE backslash-escaped
	function convert_ERE_backslash_char(ch)
	{
		if (ch[0] !== '\\')
			throw new Error('internal error');
		if (ch.length<2)
			throw new Error('internal error');

		// In ERE, backslash-character have no special meaning
		// (officially: undefined meaning, but GNU grep treats '\d' as 'd' when in BRE).
		// But in Javascript, these DO have special meaning. so double-escape them.
		// e.g.
		//   echo d | grep -E '\d'   => prints 'd'
		//   echo 1 | grep -E '\d'   => prints nothing
		//   echo d | grep -P '\d'   => prints nothing
		//   echo 1 | grep -P '\d'   => prints '1'
		if ( (ch[1] >= 'a' && ch[1] <= 'z') || ( ch[1]>='A' && ch[1] <='Z'))
			return '\\\\' + ch[1];

		// Otherwise, return as is.
		// (e.g. for "\1", but also other undefined tokens)
		return ch;
	}

	// Convert Equivalent classes [=XXX=]
	// Section 9.3.5 Item #5
	function convert_bracket_equiv_class(name)
	{
		//If it's one character, pass it as-is, but convert it to
		//explicit ASCII hex-code first.
		//This is done to avoid tricky situations such as:
		//   '[a1[=]=]]'
		// which is a valid regex (allow 'a' or '1' or ']'), but converting it to:
		//   '[a1]]'
		// is not the same meaning. So we convert it to:
		//   '[a1\x5d]'
		if (name.length===1)
			return '\\x' + name.charCodeAt(0).toString(16);

		//The locale we emulate doesn't support any equivalent classes
		throw new Error("Invalid Equivalence class: [=" + name + "=]");
	}

	// Convert Collation Symbol [.XX.]
	// Section 9.3.5 Item #6
	function convert_bracket_collation_symbol(symb)
	{
		//If it's one character, pass it as-is, but convert it to
		//explicit ASCII hex-code first.
		//This is done to avoid tricky situations such as:
		//   '[a1[.].]]'
		// which is a valid regex (allow 'a' or '1' or ']'), but converting it to:
		//   '[a1]]'
		// is not the same meaning. So we convert it to:
		//   '[a1\x5d]'
		if (symb.length===1)
			return '\\x' + symb.charCodeAt(0).toString(16);

		//The locale we emulate doesn't support any collation symbols.
		throw new Error("Invalid collation symbol: [." + symb + ".]");
	}

	// Convert Character Expression Class [:alnum:]
	// Section 9.3.5 Item #7,
	// based on simplified "C" locale
	function convert_bracket_char_class(name)
	{
		switch (name)
		{
		case 'alnum':
			return 'A-Za-z0-9';
		case 'alpha':
			return 'A-Za-z';
		case 'blank':
			return ' \t';
		case 'ctrl':
			return '\x00-\x20\x7f';
		case 'digit':
			return '0-9';
		case 'graph':
			return '\x21-\x7e';
		case 'lower':
			return 'a-z';
		case 'print':
			return '\x20-\x7e';
		case 'punct':
			return '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~';
		case 'space':
			return ' \v\f\t\n\r';
		case 'upper':
			return 'A-Z';
		case 'xdigit':
			return 'A-Fa-f0-9';

		default:
			throw new Error("Invalid character class: [:" + name + ":]");
		}
	}


	function scan_backslash()
	{
		var ch = chars.shift();
		if (ch !== '\\')
			throw new Error('internal error');

		//TODO: return error?
		if (chars.length===0)
			throw new Error('trailing backslash');

		var ch = chars.shift();
		return '\\' + ch ;
	}

	/* Scan a character class expression inside a bracket expression.
	   Examples:
		[ab[.c.]de]
           Character classes are (see section "9.3.5 RE Bracket Expression"):
		[.X.]   => Collation Symbol
		[=X=]   => Equivalence class
		[:X:]   => character class
	*/
	function scan_special_char_class()
	{
		var result = "";
		var ok = false;
		if (chars.length<2)
			throw new Error('Internal error');
		var ch = chars.shift();
		if (ch !== '[')
			throw new Error('internal error');
		var type = chars.shift();
		if (! (type === ':' || type ==='=' || type === '.') )
			throw new Error('internal error');

		while (chars.length>=2) {
			if (chars[0] === type && chars[1] === ']') {
				chars.shift();
				chars.shift();
				ok = true;
				break;
			}
			result += chars.shift();
		}

		if (!ok)
			throw new Error('Unmatched character classs [' + type);

		if (type === ':')
			return convert_bracket_char_class(result);
		else if (type === '.')
			return convert_bracket_collation_symbol(result);
		else
			return convert_bracket_equiv_class(result);
	}

	/* scan characteres inside a bracket expression.
           In a bracket expression, all characters lose their special meaning,
           except right-bracket (in non-first position),
           and character classes expression ( [:alnum:] ). */
	function scan_bracket_content_expression()
	{
		var result = "";
		var peek_next_token;
		while (chars.length > 0) {
			// Check for special bracket expressions
			if ( chars[0]==='[' && chars.length>=2 &&
			     ( chars[1]==='=' || chars[1] === ':' || chars[1] ==='.' ) ) {
				result += scan_special_char_class() ;
				continue;
			}

			// otherwise, scan any chararcter EXCEPT closing right-bracket
			// (all other chararcters loose their speacil meaning in a bracket expression)
			peek_next_token = chars[0];
			// Inside a bracket expression, a right-bracket ends the expression
			if (peek_next_token == ']')
				break;


			chars.shift(); //consume token
			result += peek_next_token;
		}
		return result;
	}

	/* Scans a bracket expression, starting with '[' ending with ']' */
	function scan_bracket_expression()
	{
		var ch = chars.shift();
		var invert = "" ;
		var right_bracket = "";
		if (ch !== '[')
			throw new Error('internal error');

		//Negation, allowed as optional first character in bracket expression
		if (chars.length>0 && chars[0] === '^')
			invert = chars.shift();

		//Right-closing bracket loses its meaning if its the FIRST character
		//in a bracket-expression (or after optional ^)
		// (Section 9.3.5 item #1)
		if (chars.length>0 && chars[0] === ']')
			right_bracket = chars.shift();

		var bracket_content = scan_bracket_content_expression()

		if (chars.length===0 || chars.shift() !== ']' )
			throw new Error("unmatched [ or [^");

		return '[' + invert + right_bracket + bracket_content + ']';
	}

	/* Scan a regular expression, in BRE or ERE syntax,
           and convert to Javascript-compatible Regexp with the same semantics */
	function scan_regexp()
	{
		var result = "";
		while (chars.length > 0) {
			var peek_next_token = chars[0];
			switch (peek_next_token)
			{
			case '\\':
				result += convert_regex_backlash_char(scan_backslash());
				break;

			case '[':
				result += scan_bracket_expression();
				break;

			default:
				chars.shift(); //consume token
				result += convert_regex_char(peek_next_token);
				break;
			}
		}
		return result;
	}

	return scan_regexp();
}

/* Given a regex string in BRE syntax, returns a regex string
 * which can be used with Javascript's RegExp and have the same semantics as the BRE string */
function regex_BRE_to_JS(text)
{
	return __convert_regex_POSIX_to_JS(text,"BRE");
}
this.regex_BRE_to_JS = regex_BRE_to_JS;

/* Given a regex string in BRE syntax, returns a regex string
 * which can be used with Javascript's RegExp and have the same semantics as the ERE string */
function regex_ERE_to_JS(text)
{
	return __convert_regex_POSIX_to_JS(text,"ERE");
}
this.regex_ERE_to_JS = regex_ERE_to_JS;

/* Given a regex string in FNMATCH(3) syntax, returns a regex string
 * which can be used with Javascript's RegExp and have the same semantics as the fnmatch(3) string */
function regex_fnmatch_longest_to_JS(text)
{
	return __convert_regex_POSIX_to_JS(text,"fnmatch_longest");
}
this.regex_fnmatch_longest_to_JS = regex_fnmatch_longest_to_JS;
function regex_fnmatch_shortest_to_JS(text)
{
	return __convert_regex_POSIX_to_JS(text,"fnmatch_shortest");
}
this.regex_fnmatch_shortest_to_JS = regex_fnmatch_shortest_to_JS;

}
