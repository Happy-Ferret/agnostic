/****************************************
 * This file is part of UNIX Guide for the Perplexed project.
 * Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
 * Released under GPLv3 or later.
 ****************************************/

/*
A Testing framework for ShellExecutor.
*/
"use strict";

var assert = require('assert');

var OperatingSystem = require('os/os_state');
var FileSystem = require('os/filesystem');
var Streams = require('os/streams');
var ProcessState = require('os/process_state');

var load_shell_parser = require('utils/shell_parser_loader');
var shell_parser = load_shell_parser();

var ShellExecutor = require('shell/shell_executor2');

var os = new OperatingSystem();
var fs = new FileSystem();
var ps = new ProcessState(os,fs);

var sh = new ShellExecutor(ps);

module.exports = run_shell_tests;

/*
When the Shell Executor wants to run an external command
(i.e. not a shell-builtin), it uses this call back.

For the testing framework, two commands are implemented:
	"echo" - each command-line parameter will be printed to STDOUT
	"env"  - each environment variable will be printed to STDOUT.
*/
sh.set_external_program_callback(function(process_state,command_name,argv){
	argv.shift(); // skip the first arg: the program's name.

	if (command_name === "env") {
		var env = process_state.environ();
		var keys = Object.keys(env);
		keys.sort();
		for (var i in keys) {
			var name = keys[i];
			var value = env[name];
			process_state.stdout.put_line(name + "=" + value);
		}
	}
	else if (command_name === "echo") {
		for (var i in argv) {
			process_state.stdout.put_line(argv[i]);
		}
	} else {
		process_state.stderr.put_line("Testing Framework failure: unknown command '" + command_name + "'");
		return 1;
	}
	return 0;
});

/*
Runs a shell command.
1. The command line (one string) will be parsed by the POSIX parser
2. The pasred-tree will be run by the shell executor
3. The returned object will contain:
	{
		exit_code: N    //ONLY IF the exit-code was non-zero
		stdout: [ ]     //ONLY IF stdout wasn't enpty
		stderr: [ ]	//ONLY IF stderr wasn't empty
	}
*/
function run_shell_command(text)
{
	var cmd,exit_code;
	try {
		cmd = shell_parser.parse(text);
	} catch (e) {
		console.error("Shell-Parser failed on command '" + text + "'");
		throw e;
	}
	try {
		exit_code = sh.ExecuteCommand(cmd);
	} catch (e) {
		console.error("Shell-Executor failed on command '" + text + "'");
		throw e;
	}
	var stdout = ps.stdout.__get_lines();
	var stderr = ps.stderr.__get_lines();

	var result = { };
	if (exit_code !== 0)
		result["exit_code"] = exit_code;
	if (stdout.length>0)
		result["stdout"] = stdout;
	if (stderr.length>0)
		result["stderr"] = stderr;

	return result;
}

function run_shell_tests(tests)
{
	var seen_tests = {} ;

	for (var i in tests) {
		var name = tests[i][0];
		var cmd  = tests[i][1];
		var expected = tests[i][2];
		var result;

		if (name in seen_tests)
			throw "run_shell_tests error: duplicated test name '" + name + "'";
		seen_tests[name] = 1;

		try {
			result = run_shell_command(cmd);
			assert.deepEqual(result, expected);
		} catch (e) {
			console.error(name + ": FAILED");
			console.error(e);
			throw e;
		}
		console.log(name + ": OK");
	}
}
