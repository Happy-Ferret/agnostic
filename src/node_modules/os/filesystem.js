/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html
*/

/*
 FileSystem representation
*/
"use strict";

//TODO: re-implement 'path.resolve' without requiring NodeJS's version
var path = require('path');

var Storage = require('os/storage_object');
var str_utils = require('utils/string_utils');
var ob_utils = require("utils/object_utils");

module.exports = FileSystem;

function FileSystem() {
	this.name = "FileSystem";

	//Root directory object
	var d = new Storage.Directory();
	d.chown(0,0);   //TODO: use current UID/GID of calling process
	d.chmod(493);  //TODO: 493=0755,  use umask of calling process

	this.max_inode = 1 ;
	this.inodes = { 1 : d };
	this.hierarchy = { "/" : { "inode":1, "type": "directory", "subnodes":{} } };
}

/* TODO:
 * 1. use standard errno ?
 */
function FilesystemException(message, relatedfile) {
		this.message = message ;
		this.name = "FilesystemException";
		this.relatedfile = relatedfile ;
		this.toString = function() {
			return message + " (file: '" + this.relatedfile + "')" ;
		}
	}
FilesystemException.prototype = new Error();
FilesystemException.prototype.constructor = FilesystemException;

//Tie the 'FileSystemException' class to 'Filesystem.exception'
//Is this an accepted Javascript hack for big projects and per-class exceptions?
FileSystem.prototype.exception = FilesystemException ;


// This limits the number of files to Javascript's integer...
FileSystem.prototype.__allocate_inode = function(name) {
	this.max_inode++;
	return this.max_inode;
}

FileSystem.prototype.path_exists = function(name) {
	return (this.__get_hnode(name)!==null);
}

FileSystem.prototype.is_directory = function(name) {
	var i = this.__get_hnode(name);
	return (i !== null
	        && ( i["type"] === "directory" ));
}
FileSystem.prototype.is_file = function(name) {
	var i = this.__get_hnode(name);
	return (i !== null
	        && ( i["type"] === "file" ));
}

FileSystem.prototype.__validate_hnodes = function() {
	var root = this.hierarchy["/"];
	var inodes = this.inodes ;

	var seen_inodes = { } ;

	var validate_node = function(root,path) {
		if (! ( "type" in root ) )
			throw "Filesystem internal error: path(" + path +
				") has 'root' without 'type':" + JSON.stringify(root);
		if (root["type"] !== "directory" && root["type"] !== "file")
			throw "Filesystem internal error: path(" + path +
				") has 'root' with invalid 'type':" + JSON.stringify(root);

		if (! ( "inode" in root ) )
			throw "Filesystem internal error: path(" + path +
				") has 'root' without 'inode':" + JSON.stringify(root);
		var inode = root["inode"];
		if (! (inode in inodes) )
			throw "Filesystem internal error: path(" + path +
				") has 'root' with non-existing 'inode':" + JSON.stringify(root);

		seen_inodes[inode] = 1 ;

		if (root["type"] !== "directory")
			return ;

		if ( !("subnodes" in root))
			throw "Filesystem internal error: path(" + path +
				") has 'root' with directory and no 'subnodes':" + JSON.stringify(root);
		var subnodes = root["subnodes"];
		for (var i in subnodes) {
			validate_node(subnodes[i], path + "/" +i);
		}
	}

	validate_node(root,"/");

	for (var i in inodes) {
		if (! (i in seen_inodes) )
			throw "Filesystem internal error: inode(" + i +
				") doesn't have a corresponding hierarchy path:" + JSON.stringify(inodes[i]);
	}
}

FileSystem.prototype.__get_hnode = function(name) {
	var abspath = path.resolve(name);
	if (abspath === "")
		throw "Filesystem internal error: path_exists called with empty path";
	if (abspath === "/")
		return this.hierarchy[ "/" ]; //root directory always exists

	abspath = abspath.slice(1) ;
	var levels = abspath.split("/");
	var root = this.hierarchy["/"];
	while (levels.length>0) {
		// This can happen if the requested path treats an existing file
		// as a subdirectory (e.g. "/tmp/foo.txt/bar.txt" )
		// the level "foo.txt" will not be a "directory",
		// and can't be traversed further
		if ( root["type"] !== "directory" )
			return null;

		var subnodes = root["subnodes"];

		//The next sub-directory/file to check
		var current_name = levels.shift();

		// Current level in hierarchy doesn't have the requested
		// item as a subnode.
		if (!(current_name in subnodes))
			return null;

		root = subnodes[current_name];
	}

	return root;
}

FileSystem.prototype.mkdir = function(name) {
	ob_utils.VerifyString(name);

	//TODO: fix this - implement "cwd" ?
	if (!str_utils.startsWith(name,"/"))
		throw "Implementation Limitation: mkdir requires absolutes path (got '" + name + "')";

	var abspath  = path.resolve(name);
	var basename = path.basename(abspath);
	var dirname  = path.dirname(abspath);

	if (this.path_exists(abspath))
		throw new FilesystemException("File/Directory Exists", name);
	if (!(this.path_exists(dirname)))
		throw new FilesystemException("No such file (parent directory doesn't exist)", name);
	if (!(this.is_directory(dirname)))
		throw new FilesystemException("Can't create directory (parent path isn't a directory)", name);

	var inode = this.__allocate_inode();

	var d = new Storage.Directory();
	d.chown(0,0);   //TODO: use current UID/GID of calling process
	d.chmod(493);  //TODO: use umask of calling process
	this.inodes[ inode ] = d ;

	var i = this.__get_hnode(dirname);
	i["subnodes"][basename] = { "inode":inode, "type":"directory", "subnodes":{} } ;

	this.__validate_hnodes(this);
}

FileSystem.prototype.openfile = function(name,create_if_needed) {
	ob_utils.VerifyString(name);

	//TODO: fix this - implement "cwd" ?
	if (!str_utils.startsWith(name,"/"))
		throw "Implementation Limitation: mkdir requires absolutes path (got '" + name + "')";

	var abspath  = path.resolve(name);
	var basename = path.basename(abspath);
	var dirname  = path.dirname(abspath);

	var exists = this.path_exists(abspath);
	var is_file = this.is_file(abspath);
	if (exists && !is_file)
		throw new FilesystemException("Can't open file (path is not a regular file)", name);

	if (!exists) {
		if (!create_if_needed)
			throw new FilesystemException("File/Directory does not exist", name);

		if (!(FileSystem.prototype.path_exists.call(this,dirname)))
			throw new FilesystemException("Can't create file (parent directory doesn't exist)", name);
		if (!(FileSystem.prototype.is_directory.call(this,dirname)))
			throw new FilesystemException("Can't create file (parent path isn't a directory)", name);

		var inode = this.__allocate_inode();
		var f = new Storage.File();
		f.chown(0,0);   //TODO: use current UID/GID of calling process
		f.chmod(493);  //TODO: use umask of calling process
		this.inodes[ inode ] = f ;

		var i = this.__get_hnode(dirname);
		i["subnodes"][basename] = { "inode":inode, "type":"file" };
		this.__validate_hnodes();

		return f;
	} else {
		var i = this.__get_hnode(abspath);
		var inode = i["inode"];
		var f = this.inodes[inode];
		return f;
	}
}

FileSystem.prototype.remove = function(name) {
	ob_utils.VerifyString(name);

	//TODO: fix this - implement "cwd" ?
	if (!str_utils.startsWith(name,"/"))
		throw "Implementation Limitation: mkdir requires absolutes path (got '" + name + "')";

	var abspath  = path.resolve(name);
	var dirname  = path.dirname(abspath);
	var basename = path.basename(abspath);

	var exists = this.path_exists(abspath);
	if (!exists)
		throw new FilesystemException("No such file/directory", name);

	//parent directory
	var prnt = this.__get_hnode(dirname);
	var subnodes = prnt["subnodes"];

	if (! (basename in subnodes) )
		throw "Filesystem internal error: path("+abspath+") not found in parent's subnodes";

	var hnode = subnodes[basename];
	var inode = hnode["inode"];

	if ( hnode["type"] === "directory" ) {
		var subsubnodes = hnode["subnodes"];
		if (!ob_utils.IsObjectEmpty(subsubnodes))
			throw new FilesystemException("Directory not empty");
	}

	delete subnodes[basename];
	delete this.inodes[inode];

	this.__validate_hnodes();
}

FileSystem.prototype.opendir = function(name) {
	ob_utils.VerifyString(name);

	//TODO: fix this - implement "cwd" ?
	if (!str_utils.startsWith(name,"/"))
		throw "Implementation Limitation: mkdir opendir absolutes path (got '" + name + "')";

	var abspath  = path.resolve(name);
	var basename = path.basename(abspath);
	var dirname  = path.dirname(abspath);

	var exists = this.path_exists(abspath);
	if (!exists)
		throw new FilesystemException("Directory doesn't exist", name);
	var is_directory = this.is_directory(abspath);
	if (exists && !is_directory)
		throw new FilesystemException("Path is not a directory", name);

	var i = this.__get_hnode(abspath);
	var inode = i["inode"];
	var d = this.inodes[inode];
	return d;
}

FileSystem.prototype.readdir = function(name) {
	ob_utils.VerifyString(name);

	//TODO: fix this - implement "cwd" ?
	if (!str_utils.startsWith(name,"/"))
		throw "Implementation Limitation: readdir requires absolutes path (got '" + name + "')";

	var abspath  = path.resolve(name);
	var exists = this.path_exists(abspath);
	if (!exists)
		throw new FilesystemException("Directory doesn't exist", name);
	var is_directory = this.is_directory(abspath);
	if (exists && !is_directory)
		throw new FilesystemException("Path is not a directory", name);

	var i = this.__get_hnode(abspath);
	var subnodes = i["subnodes"];
	var results = [] ;
	if (abspath === "/")
		abspath = "" ;
	for (var i in subnodes) {
		results.push( abspath + "/" + i );
	}
	return results;
}

FileSystem.prototype.reset = function() {
	var d = new Storage.Directory();
	d.chown(0,0);   //TODO: use current UID/GID of calling process
	d.chmod(493);  //TODO: use umask of calling process
	this.max_inode = 1 ;
	this.inodes = { 1 : d };
	this.hierarchy = { "/" : { "inode":1, "type": "directory", "subnodes":{} } };

	this.__validate_hnodes();
}

FileSystem.prototype.debug_dump = function() {
	console.log("inodes = {");
	for (var i in this.inodes) {
		var fullpath = i;
		var storage_obj = this.inodes[i];
		console.log("  { \"" + fullpath + "\" => '%j'", storage_obj ) ;
	}
	console.log("}");

	var str = JSON.stringify(this.hierarchy, undefined, 2);
	console.log("hierarchy = " + str);
}

