/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html
*/

/*
Process State Encapsulation.

This module contains functions which could be consdered as
kernel system-calls which return Per-Process information.
*/
"use strict";

module.exports = ProcessState;

var OperatingSystem = require('os/os_state');
var FileSystem = require('os/filesystem');
var Streams = require('os/streams');
var obj_utils_wrapper = require("utils/object_utils");
var ob_utils = obj_utils_wrapper.ob_utils;

/* TODO: this is nodeJS specific module, will not work in the browser.
   find a replacement, or re-implement. */
var path = require("path");


function ProcessState(OS,FS) {

	if (! (OS instanceof OperatingSystem) )
		throw new TypeError("internal error: OS parameter is not an OperatingSystem");

	if (! (FS instanceof FileSystem) )
		throw new TypeError("internal error: FS parameter is not a FileSystem");


	function getOS()
	{
		return OS;
	}

	function getFS()
	{
		return FS;
	}


	var resolve_path = path.resolve;

	/* Current and Parent Process ID */
	var pid = getOS().allocate_pid() ;
	var ppid = 1 ; // default Parent PID is 1

	/* Current Working Directory */
	var cwd = "/" ;

	/* Environment Variables */
	var env = {} ;

	var stdin = new Streams.InputStream();
	var stdout = new Streams.OutputStream();
	var stderr = new Streams.OutputStream();

	var last_exit_code = null ; // exit code of last process

	/*
	Clones the current ProcessState and returns a new ProcessState.
	NOTE:
	Major different from 'posix' fork/clone is that STDIN/STDERR/STDOUT
	are NOT cloned, but are initialized to new empty streams.
	It is the caller's responsibility to take care of STDIN/STDOUT/STDERR
	assignment (e.g. piping/redirections).
	*/
	function clone()
	{
		var new_ps = new ProcessState(getOS(),getFS());
		new_ps.ppid = pid;
		new_ps.cwd =  cwd;
		for (var i in env) {
			new_ps.env[i] = env[i];
		}
		return new_ps;
	}


	function getpid() { return pid ; }
	function getppid() { return ppid ; }

	function getcwd() { return cwd; }
	function chdir(path)
	{
		ob_utils.VerifyString(path);
		//TODO: Verify valid path
		cwd = resolve_path(cwd,path);
	}

	/* setenv(3) */
	function setenv(name,value,overwrite)
	{
		ob_utils.VerifyString(name);
		ob_utils.VerifyString(value);
		ob_utils.VerifyBoolean(overwrite);

		if ( !(name in env) || overwrite )
			env[name] = value;

		return 0;
	}
	function unsetenv(name)
	{
		if ( name in env )
			delete env[name];

		return 0;
	}
	/* Unlike a real OS, access to ENV is encapsulated. */
	/* existsenv() - returns TRUE of FALSE, if the key exists in the environment */
	function existsenv(name)
	{
		ob_utils.VerifyString(name);
		return ( name in env ) ;
	}
	/* getenv() - returns the value of key 'NAME' in the environment,
			or the value of 'def' if 'NAME' doesn't exist */
	function getenv(name,def)
	{
		ob_utils.VerifyString(name);
		ob_utils.VerifyString(def);
		if ( existsenv(name) )
			return env[name];
		return def;
	}
	/* environ returns a COPY of the environment hash -
	   so processes can iterate it but not change it directly */
	function environ()
	{
		var tmp = {} ;
		for (var key in env) {
			tmp[key] = env[key];
		}
		return tmp;
	}
	function clearenv()
	{
		env = {} ;
	}

	this.getpid = getpid;
	this.getppid = getppid;
	this.getcwd = getcwd;
	this.chdir = chdir;
	this.setenv = setenv;
	this.unsetenv = unsetenv;
	this.existsenv = existsenv;
	this.getenv = getenv;
	this.environ = environ;
	this.clearenv = clearenv;
	this.stderr = stderr;
	this.stdin = stdin;
	this.stdout = stdout;
	this.OS = getOS;
	this.FS = getFS;
	this.clone = clone;
	return this;
}
