/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/
"use strict";

/*
This module provides a shell object,
which can repeatedly evaluate shell commands (and execute programs).

TODO:
Currently, all known programs are loaded.
In the future, allow only specific programs (or programs from other 'packages').
*/
var ob_utils = require('utils/object_utils');

var OperatingSystem = require('os/os_state');
var FileSystem = require('os/filesystem');
var ProcessState = require('os/process_state');

var ShellExecutor = require('shell/shell_executor2');

var Program_basename = require('programs/basename');
var Program_cat = require('programs/cat');
var Program_cut = require('programs/cut');
var Program_date = require('programs/date');
var Program_dirname = require('programs/dirname');
var Program_echo = require('programs/echo');
var Program_false = require('programs/false');
var Program_grep = require('programs/grep');
var Program_head = require('programs/head');
var Program_ls = require('programs/ls');
var Program_printf = require('programs/printf');
var Program_seq = require('programs/seq');
var Program_shell = require('programs/shell');
var Program_tac = require('programs/tac');
var Program_tail = require('programs/tail');
var Program_true = require('programs/true');
var Program_wc = require('programs/wc');

module.exports = InteractiveShell;


function InteractiveShell(shell_parser)
{
	ob_utils.VerifyObject(shell_parser);
	// Can't check 'instanceof' because it could be of several types - so check duck-typing.
	if (!shell_parser.hasOwnProperty('parse'))
		throw new Error("shell_parser parameter is invalid (missing 'parse' method)");

	var programs = {
		"basename": Program_basename,
		"cat": Program_cat,
		"cut": Program_cut,
		"date": Program_date,
		"dirname": Program_dirname,
		"echo": Program_echo,
		"false": Program_false,
		"grep": Program_grep,
		"head": Program_head,
		"printf": Program_printf,
		"ls" : Program_ls,
		"seq": Program_seq,
		"sh": Program_shell,
		"tac": Program_tac,
		"tail": Program_tail,
		"true": Program_true,
		"wc": Program_wc,
	};
	this.programs = programs ;

	this.os = new OperatingSystem();
	this.fs = new FileSystem();
	this.ps = new ProcessState(this.os,this.fs);
  var ps = this.ps;
	this.shell_exec = new ShellExecutor(this.ps);
	this.shell_parse = shell_parser;

	// When the shell-Executor needs to run an external program,
	// it will call this function.
	this.shell_exec.set_external_program_callback(function(process_state,command_name,argv){
		if ( command_name in programs ) {
			var prog_constructor = programs[command_name];
			var prog_obj = new prog_constructor();
			return prog_obj.run(process_state,argv);
		} else {
			process_state.stderr.put_line("Agnostic Shell Emulation error: unknown command '" + command_name + "'");
			return 1;
		}
	});


	// When the shell (or an executed program) needs to read from STDIN,
	// it will call this method.
	// For now, just notify the user and return empty data.
	// NOTE:
	//   This callback only applies to the STDIN of the shell and
	//   the inherited programs.
	//   If the shell command iteself includes a pipe (e.g. 'seq 10 | wc -l'),
	//   Then the STDIN of 'wc -l' will be properly set from the STDOUT of 'seq 10',
	//   and this callback method will not be used.
	this.ps.stdin.fill_input_callback = function() {
		ps.stderr.put_line("Agnostic Shell Emulation Warning: The command tried to read from STDIN - returning empty data");
		return [] ;
	}
}

/* The main interface to the interactive shell:
   1. Parses the shell command
   2. Executes it (and possibly calling external programs)
   3. returns an object with the following keys:
	{
		exit_code: N
		stdout: [ ]     //ONLY IF stdout wasn't enpty
		stderr: [ ]	//ONLY IF stderr wasn't empty
		text_command: "STRING" //the original input shell command
		parsed_command: The internal tree representation of the parsed command.
	}
*/
InteractiveShell.prototype.execute = function(text)
{
	var cmd,exit_code;
	var result = { } ;
	result.text_command = text;
	try {
		cmd = this.shell_parse.parse(text);
		result.parsed_command = cmd;
	} catch (e) {
		var errmsg = "Shell-Parser failed to parse command '" + text + "'";
		console.error(errmsg);
		console.error(e);
		result.exit_code = 1;
		result.stderr = [ errmsg ];
		return result;
	}

	try {
		exit_code = this.shell_exec.ExecuteCommand(cmd);
	} catch (e) {
		var errmsg = "Shell-Executor failed on command '" + text + "'";
		console.error(errmsg);
		console.error(e);
		result.exit_code = 1;
		result.stderr = [ errmsg ];
		return result;
	}

	var stdout = this.ps.stdout.__get_lines();
	var stderr = this.ps.stderr.__get_lines();

	result.exit_code = exit_code;

	if (stdout.length>0)
		result.stdout = stdout;
	if (stderr.length>0)
		result.stderr = stderr;

	return result;
}

