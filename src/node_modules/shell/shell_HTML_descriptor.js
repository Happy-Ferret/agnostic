/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/

/*
   This module iterates over a Shell-Parse-Tree (as generated by 'posix_shell.pegjs'),
   and produces an annotated HTML tags.


   This module requires the functions from 'utils.js' to be loaded.

   Usage Example:
	require("utils.js");
	require("posix_shell.js")
	require("shell_descriptor.js");

	// Any shell command line
	var shell_command = "FOO=BAR seq 10 | wc -l && true || echo fail" ;

	// ParseTree is JSON object, representing the shell command
	var ParseTree = posix_shell_parser.parse(shell_command);

	// description should be (very) similar to the original 'shell_command' .
	// (There will be differences in white space, and redirections order.)
	var description = DescribeShellCommand(ParseTree);

 */
Shell_HTML_Descriptor = (function() {

var command_order = 0 ;
var command_level = 0 ;
var command_level_max = 0;

/* from:
http://stackoverflow.com/questions/1144783/replacing-all-occurrences-of-a-string-in-javascript
*/
function replaceAll(find, replace, str) {
  return str.replace(new RegExp(find, 'g'), replace);
}

function StartCommand(obj)
{
	command_order = 0 ;
	command_level = 0 ;
	command_level_max = 0 ;

	var html = Command(obj);
	for (var i = 1; i<=command_level_max; i++) {
		var from = "cmdleveltmp" + i;
		var to   = "cmdlevel" + (command_level_max-i+1);

		console.log("replacing '" + from + "' to '" + to + "'");
		html = replaceAll(from,to,html);
	}
	return html;
}

function start_span(class_name,level)
{
	var html = "<span class=\"" + class_name;
	if (level)
		html += " cmdleveltmp" + parseInt(level) ;
	html += "\">";
	return html ;
}

function end_span()
{
	return "</span>";
}

function simple_span(class_name,content)
{
	var html = "<span class=\"" + class_name + "\">" + content + "</span>";
	return html;
}

/*
Command() - The starting point of Shell-Syntax-Tree parsing.
*/
function Command(obj)
{
	var type = GetOneKey(obj);
	var value = obj[type];
	var html;

	command_level++;
	if (command_level > command_level_max)
		command_level_max = command_level;

	switch (type)
	{
	case "SimpleCommand":
		html = SimpleCommand(value);
		break;

	case "and_or_list":
		html = AndOrList(value);
		break;

	case "list":
		html = List(value);
		break;

	case "pipeline":
		html = Pipeline(value);
		break;

	case "compound_subshell":
		html = CompoundSubshell(value);
		break;

	case "compound_currentshell":
		html = CompoundCurrentshell(value);
		break;
	default:
		throw "Invalid Command type '" + type + '"';
	}

	command_level--;

	return html ;
}

/*
Pipeline() - process commands in a pipeline (e.g. "seq 10 | wc -l").
*/
function Pipeline(obj)
{
	VerifyArray(obj);
	var pipe_desc = obj.map(Command).join(" " + simple_span("pipesymbol","|") + " ");
	return start_span("pipecmd",command_level) + pipe_desc + end_span() ;
}

/*
List() - process commands line a sequential (or background) list
         (e.g. "true ; sleep 60 & false ;")o

$ ./parse 'foo ; bar & baz'
{
  "list": [
    {
      "foreground": {
        "SimpleCommand": { "command": [ { "literal": "foo" } ] }
      }
    },
    {
      "background": {
        "SimpleCommand": { "command": [ { "literal": "bar" } ] }
      }
    },
    {
      "foreground": {
        "SimpleCommand": { "command": [ { "literal": "baz" } ] }
      }
    }
  ]
}

During Execution:
1. Run each command.
2. Commands share STDIN/STDOUT/STDERR (unless redirected for each command).
3. Since it is not likely "background" execution will be emulated here,
   even background commands will be executed sequentially in foreground.
*/
function List(obj)
{
	var result = "" ;
	VerifyArray(obj);
	obj.forEach(function(item,idx){
		var exec_type = GetOneKey(item);
		var exec_char = "" ;
		switch (exec_type)
		{
		case "foreground":
			exec_char = " " + simple_span("list_terminator", ";");
			break;
		case "background":
			exec_char = " " + simple_span("list_terminated", "&");
			break;
		default:
			throw "Invalid list exec-type '" + exec_type + "', expecting 'foreground' or 'background'" ;
		}

		var command = Command( item[exec_type] );

		if ( idx != (obj.length-1) || exec_type == "background" )
			command += exec_char ;

		result += command ;
	});

	return start_span("list",command_level) + result + end_span();
}


/*
AndOrList() - Process commands in an And/Or list
              (e.g. "true && echo ok || echo fail")

$ ./parse 'true && foo || bar'
{
  "and_or_list": [
    {
      "SimpleCommand": { "command": [ { "literal": "true" } ] }
    },
    "&&",
    {
      "SimpleCommand": { "command": [ { "literal": "foo" } ] }
    },
    "||",
    {
      "SimpleCommand": { "command": [ { "literal": "bar" } ] }
    }
  ]
}

During Execution:
1. Run the first command.
2. The the following commands depending on the previous exitcode
   and the operation (&& or ||)
*/
function AndOrList(obj)
{
	VerifyArray(obj);
	var cmd = obj[0];
	var list_desc = start_span("AndOrList",command_level) + Command(cmd);
	var i = 1 ;
	while (i<obj.length) {
		var condition = obj[i];
		var cmd = obj[i+1];
		i += 2;
		list_desc = list_desc + " " + simple_span("AndOrListOperator",condition)+ " " + Command(cmd);
	}
	list_desc += end_span();
	return list_desc;

}
/*
SimpleCommand() - Process a single execution command,
                  (e.g. equivalent to a single program to run, a single call to 'exec()')

A Simple Command can contain each of the following:
1. Environment variable assignments
2. Command (i.e. program name, shell alias, shell function) + parameters
3. Redirections

Examples:

## No assignments or redirections here
$ ./parse 'seq 1 2 100'
{
  "SimpleCommand": {
    "command": [
      { "literal": "seq" },
      { "delimiter": null },
      { "literal": "1" },
      { "delimiter": null },
      { "literal": "2" },
      { "delimiter": null },
      { "literal": "100" }
    ]
  }
}

## Assignments and a command
$ ./parse 'CC=clang make'
{
  "SimpleCommand": {
    "command": [
      { "literal": "make" }
    ],
    "assignments": [
      {
        "CC": [ { "literal": "clang" } ]
      }
    ]
  }
}

## command and redirection
$ ./parse 'dmesg -c >/dev/null'
{
  "SimpleCommand": {
    "command": [
      { "literal": "dmesg" },
      { "delimiter": null },
      { "literal": "-c" }
    ],
    "redirections": [
      {
        "filedescriptor": 1,
        "forceclobber": false,
        "filename": [ { "literal": "/dev/null" }
        ],
        "type": "output_file"
      }
    ]
  }
}

Valid Simple-Commands can contain either of the above three - that is,
A Simple-Command with only Environment-Variable-Assignment is valid (it only
changes the shell's variables without executing any program).

See section "2.9.1 Simple Commands" for details, and IMPORTANT notes
about processing order of assignment/redirection/execution.

During Execution:
1. Perform Environment Variable assignment (if any)
2. Prepare redirections (if any)
3. Execute command (if any)
    3.1. "command" will be a list of tokens.
         After evaluation (and paramter expansion and field-splitting),
         the first element is considered the program to execute (or alias,function,etc.)
*/
function SimpleCommand(obj)
{
	VerifyAllowedKeys(obj, ["command","redirections","assignments"]);

	var assignment_desc = "" ;
	var tokens_desc = "" ;
	var redirection_desc = "" ;
	if ("assignments" in obj)
		assignment_desc = simple_span("Assignments", Assignments( obj["assignments"] ) ) + "&nbsp;";
	if ("redirections" in obj)
		redirection_desc = "&nbsp;" + simple_span("Redirections",Redirections( obj["redirections"] ))
	if ("command" in obj)
		tokens_desc = simple_span("ExecTokens",Token( true, obj["command"] ));

	var v =  start_span("SimpleCommand",command_level) + assignment_desc
		 + tokens_desc
		 + redirection_desc
		 + end_span();
	return v;
}


/*
Assignments() - Process list of envrionment variable assignments.

Example:
$ ./parse 'FOO=BAR HELLO=WO${RLD}'
{
  "SimpleCommand": {
    "assignments": [
      {
        "FOO": [ { "literal": "BAR" } ]
      },
      {
        "HELLO": [
          { "literal": "WO" },
          { "envvar": "RLD" }
        ]
      }
    ]
  }
}

NOTE: Assignments are always a part of SimpleCommand.

During Execution:
1. Evaluation the value of each assignment
2. Set the value in the shell execution environment
*/
function Assignments(obj)
{
	VerifyArray(obj);
	var results = [] ;
	obj.forEach(function(item){
		var varname = GetOneKey(item); //Name of the ENV variable to set.
		var value_token = item[varname]; //Value of the variable
		var value = Token(false,value_token); //Expand the value, if needed

		var desc = varname + "=" + value ;
		results.push(desc);
	});
	return results.join(" ");
}

/*
Redirections() - Process list of redirections

NOTES:
1. Redirection on the command line can appear BEFORE
the actual command, with variable assignments (though this isn't common in practice).
2. The parser collects redirections (both before and after the command)
into one key 'redirections', though order is maintained.

Examples:
./parse '<input.txt wc -l >output.txt'
{
  "SimpleCommand": {
    "command": [
      { "literal": "wc" },
      { "delimiter": null },
      { "literal": "-l" }
    ],
    "redirections": [
      {
        "filedescriptor": 0,
        "filename": [ { "literal": "input.txt" } ],
        "type": "input_file"
      },
      {
        "filedescriptor": 1,
        "forceclobber": false,
        "filename": [ { "literal": "output.txt" } ],
        "type": "output_file"
      }
    ]
  }
}

*/
function Redirections(obj)
{
	//TODO: generate descriptive string from redirection structure
	VerifyArray(obj);
	return "";
}

/*
Token() - Process token(s).

Tokens are very close to WORD in the POSIX Shell document,
with some minor implementation-related differences.
Tokens can contain:
1. unquoted characters ( 'literals' )
2. delimiters (indicating a delimiter in the input string, but see below about
   field-splitting)
3. Double-Quoted strings (with possible parameter-expansion )
4. Subshells (e.g. $() )
5. Backtick-shells
6. Arithmetic expressions
7. Environment variables (e.g. $FOO and ${FOO} )
8. Environment variables with operations (e.g. ${FOO:-BAR} )

This step corresponds to POSIX Shell Secion 2.1 "Shell Introduction" item #4,
and section "2.6 Word Expansions".

NOTES:
1. The number of input elements DOES NOT necessarily corresponds to
number of output elements - see item #2 "field splitting" in Section "2.6 Word Expansions".
For example:
     C="me -s"
     una$C -r
Has one delimiter in the input string (between $C and -r),
but after field-splitting, the command will have three items: 'uname','-s','-r' .
2. Tokens appears as VALUES of many items (e.g. environemt variable assignment,
	redirection's filenames).

EXAMPLE:
(note that the "command" key points to an array, which is the Token):
$ ./parse 'H"EL"LO${FOO-WO}$(echo rld)$((5*$(id -u)))'
{
  "SimpleCommand": {
    "command": [
      { "literal": "H" },
      { "doublequotedstring": [ { "literal": "EL" } ] },
      { "literal": "LO" },
      { "envvar_operation": {
          "value": [ { "literal": "WO" } ],
          "operation": "-",
          "envvar": "FOO"
        }
      },
      {
        "subshell": {
          "SimpleCommand": {
            "command": [
              { "literal": "echo" },
              { "delimiter": null },
              { "literal": "rld" }
            ]
          }
        }
      },
      {
        "arithmetic": {
          "arithmetics_op_list": [
            { "literal": 5 },
            "*",
            {
              "subshell": {
                "SimpleCommand": {
                  "command": [
                    { "literal": "id" },
                    { "delimiter": null },
                    { "literal": "-u" }
                  ]
                }
              }
            }
          ]
        }
      }
    ]
  }
}


During Execution:
1.  This module only describes tokens, so there's no need to execute commands
    (e.g. "id -u", or arithmetics calculations in the above example).
*/
function Token(allow_multiple_fields,obj)
{
	var results = [] ;
	VerifyBoolean(allow_multiple_fields);
	VerifyArray(obj);
	obj.forEach(function(item){
		var token_type = GetOneKey(item);
		var token_value = item[token_type];
		var desc = "" ;
		switch(token_type)
		{
		case "literal":
			desc = token_value;
			break;

		case "delimiter":
			desc = " ";
			break;

		case "singlequotedstring":
			desc = SingleQuotedString(token_value);
			break;

		case "doublequotedstring":
			desc = DoubleQuotedString(token_value);
			break;

		case 'envvar_operation':
			desc = simple_span("EnvVarOp",EnvVarOperation(token_value));
			break;

		case 'envvar':
			desc = simple_span("EnvVar",EnvVar(token_value));
			break;

		case 'arithmetic':
			desc = simple_span("Arithmetic",Arithmetic(token_value));
			break;

		case 'subshell':
			//TODO: Take STDOUT of the program, and use it as token
			desc = simple_span("subshell",Subshell(token_value));
			break;

		case 'backtickshell':
			//TODO: Take STDOUT of the program, and use it as token
			desc = simple_span("backtickshell",BacktickShell(token_value));
			break;

		default:
			throw "Unknown Posix-Shell-Token '" + token_type + '"';
		}
		results.push(desc);
	});

	/* TODO: field splitting */
	/* TODO: Filename expansion, if allowed */
	/* TODO: if 'allow_multiple_fields' === false,
		 and after field-splitting we do have multiple fields - throw an error */
	return results.join("");
}




/*
EnvVar() - Process an environment variable, based on its name.

Example:
$ ./parse '$USER'
{
  "SimpleCommand": {
    "command": [
      {
        "envvar": "USER"
      }
    ]
  }
}

During Execution:
1. Return the content of the variable, based on the current shell execution environment
*/
function EnvVar(obj)
{
	return '${' + obj + '}';
}

/*
EnvVarOperation() - Process an environment variable with an operation
                    (e.g. "${FOO:=BAR}" or "${FOO%test$(id -u)}"

An environment variable operation is represented by the following structure:
1. "envvar"    - the name of the variable. never expanded.
2. "operation" - as described in section "2.6.2 Parameter expansion"
3. "value"     - a token to assign. Could be a compounded Token, needs to
	         be recursively evalutated.

NOTE:
1. "value" might be missing, if the input syntax was "${FOO=}".

Example:
$ ./parse '${FOO:-$(uname)}'
{
  "SimpleCommand": {
    "command": [
      {
        "envvar_operation": {
          "value": [
            {
              "subshell": {
                "SimpleCommand": {
                  "command": [ { "literal": "uname" } ]
                }
              }
            }
          ],
          "operation": ":-",
          "envvar": "FOO"
        }
      }
    ]
  }
}

During Execution:
1. Return the content of the variable, based on the current shell execution environment
*/
function EnvVarOperation(obj)
{
	VerifyAllowedKeys(obj, ["envvar","operation","value"]);

	var varname = obj["envvar"];
	//TODO: when exeuting/emulating, get the content (if any)
	//	of "varname".

	var operation = obj["operation"];

	//TODO: when executing/emulating, calculate the content of
	//	the value.
	var value = "";
	/* "value" is optional - e.g. no "value" in  ${FOO=} */
	if (obj["value"]) {
		value = Token(true,obj["value"]);
	}

	//TODO: when executing/emulating, set the returned value
	//	based on the varname+operation+value.

	return '${' + varname + operation + value + '}';
}

/*
SingleQuotedString() - just like a literal value.

Single Quoted Strings are just like literals */
function SingleQuotedString(obj)
{
	return "'" + obj + "'" ;
}

/*
DoubleQuotedString() - Evalutate tokens inside a double-quoted string.
In this implementation, a Double-Quoted String is similar to any other
compound token.
See section "2.2.3 Double-Quotes".

TODO
1. and the special handling of "@".

EXAMPLE:
$ ./parse 'echo "foo$((1+4))$baz"'
{
  "SimpleCommand": {
    "command": [
      { "literal": "echo" },
      { "delimiter": null },
      {
        "doublequotedstring": [
          { "literal": "foo" },
          { "arithmetic": {
              "arithmetics_op_list": [
                { "literal": 1 },
                "+",
                { "literal": 4 }
              ]
            }
          },
          { "envvar": "baz" }
        ]
      }
    ]
  }
}

*/
function DoubleQuotedString(obj)
{
	var desc = Token(true,obj);
	return '"' + desc + '"' ;
}


/*
Subshell() - Process a subshell execution.
The command to execute can be a full-fledged shell syntax command.

Example:
$ ./parse 'echo $(uname)'
{
  "SimpleCommand": {
    "command": [
      { "literal": "echo" },
      { "delimiter": null },
      {
        "subshell": {
          "SimpleCommand": { "command": [ { "literal": "uname" } ] }
        }
      }
    ]
  }
}

During Execution:
1. During Executing/Emulation, a new Shell Execution Environment needs to be established.
2. The STDIN of the existing shell should be passed to the subshell.
3. The STDOUT of this process should be returned as a token.
*/
function Subshell(obj)
{
	/* NOTE: This can happen with an empty subshell, e.g.: "echo $()" */
	if (obj === null)
		return "$()";
	var desc = Command(obj);
	return "$(" + desc + ")";
}

/*
BacktickShell() - Process a backtick subshell

Example:
$ ./parse 'echo `uname`'
{
  "SimpleCommand": {
    "command": [
      { "literal": "echo" },
      { "delimiter": null },
      {
        "backtickshell": {
          "SimpleCommand": { "command": [ { "literal": "uname" } ] }
        }
      }
    ]
  }
}


During Execution:
1. During Executing/Emulation, a new Shell Execution Environment needs to be established.
2. The STDIN of the existing shell should be passed to the subshell.
3. The STDOUT of this process should be returned as a token.

TODO:
Backtick-shells have some pecularities. Review the standard.
*/
function BacktickShell(obj)
{
	/* NOTE: This can happen with an empty subshell, e.g.: "echo $()" */
	if (obj === null)
		return "``";
	var desc = Command(obj);
	return "`" + desc + "`";
}

/*
CompoundSubshell() - Process a compound list of commands in a subshell.
                     (e.g.   "seq 10 | ( sed -u 1q ; sort -nr)" ).

NOTES:
See "2.9.4 Compound Commands" (http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_09_04),

During Execution:
1. The commands should get STDIN from current shell,
2. The commands should return STDOUT,STDERR to current shell
   (to be printed to console, or sent to next piped program)
*/
function CompoundSubshell(obj)
{
	return start_span("CompoundSubshell",command_level) + " ( " + Command(obj) + " ) " + end_span();
}

/*
CompoundCurrentsshell() - Process a compound list of commands in current shell.
                     (e.g.   "false && { echo failed >&2 ; exit 1 ; }

NOTES:
See "2.9.4 Compound Commands" (http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_09_04),

During Execution:
1. The commands should get STDIN from current shell,
2. The commands should return STDOUT,STDERR to current shell
   (to be printed to console, or sent to next piped program)
*/
function CompoundCurrentshell(obj)
{
	return start_span("CompoundCurrentshell",command_level) + "{" + Command(obj) + " ; }" + end_span();
}


/*
Arithmetic() - Process arithmetic parameter expansions (e.g. "$((5+4))" ).

NOTE:
1. Arithmetic Expressions can contain recursive parameter expansions (e.g
   environment variables, subshells, etc.).

Example:
$ ./parse '$((1+2*$(id -u)+42))'
{
  "SimpleCommand": {
    "command": [
      {
        "arithmetic": {
          "arithmetics_op_list": [
            { "literal": 1 },
            "+",
            {
              "arithmetics_op_list": [
                { "literal": 2 },
                "*",
                {
                  "subshell": {
                    "SimpleCommand": {
                      "command": [
                        { "literal": "id" },
                        { "delimiter": null },
                        { "literal": "-u" }
                      ]
                    }
                  }
                }
              ]
            },
            "+",
            { "literal": 42 }
          ]
        }
      }
    ]
  }
}

During Execution:
Return the integer value of the operation.

TODO:
1. implement all required arithmetic operations
*/
function Arithmetic(obj)
{
	return "$((" + ArithmeticExpression(obj) + "))";
}

/*
ArithmeticExpression() - Process the possible tokens in an arithmetic expression.

*/
function ArithmeticExpression(obj)
{
	var op = GetOneKey(obj);
	var value = obj[op];
	switch (op)
	{
	case 'literal':
		return value; //TODO: convert to numeric?

	/*TODO: when executing/emulating, fetch the value.
	  NOTE: this always returns an envvar wrapped in ${}, even
		if the input syntax was not wrapped. These are functionally
		equivalent: $((A+4))  $((${A}+4)) */
	case 'envvar':
		return EnvVar(value);

	case 'arithmetics_op_list':
		return ArithmeticOpList(value);

	case 'arithmetic':
		return ArithmeticExpression(value);

	case 'subshell':
		return Subshell(value);

	default:
		throw "Uknown arithmetic operation '" + op + '"';
	}
}


/* Process an list of arithmetics operation, with the same precedence
   (eg. a list of addition/substractions, or a list of multiplications/divisions).
   During execution/emulation, 'value' should contain the accumulated value */
function ArithmeticOpList(obj)
{
	VerifyArray(obj);
	var operand = obj[0];
	var value = ArithmeticExpression(operand);
	var i = 1 ;
	while (i<obj.length) {
		var operator = obj[i];
		var operand2 = obj[i+1];
		i += 2;
		value = value + operator + ArithmeticExpression(operand2);
	}
	return value;
}

	return {
		"DescribeShellCommand" : StartCommand
		};
})();

//Ugly Hack: make it global
DescribeShellCommandHTML = Shell_HTML_Descriptor.DescribeShellCommand;
