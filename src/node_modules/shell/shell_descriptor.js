/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/

/*
   This module iterates over a Shell-Parse-Tree (as generated by 'posix_shell.pegjs'),
   and produces a one-line text description of the command (akin to "toString()).

   This module can be considered as the reference implementation and verifier
   of the parse-tree object structure and hierarchy produced by 'posix_shell.pegjs'.

   This module requires the functions from 'utils.js' to be loaded.

   Usage Example:
	require("utils.js");
	require("posix_shell.js")
	require("shell_descriptor.js");

	// Any shell command line
	var shell_command = "FOO=BAR seq 10 | wc -l && true || echo fail" ;

	// ParseTree is JSON object, representing the shell command
	var ParseTree = posix_shell_parser.parse(shell_command);

	// description should be (very) similar to the original 'shell_command' .
	// (There will be differences in white space, and redirections order.)
	var description = DescribeShellCommand(ParseTree);

 */
Shell_Descriptor = (function() {

	/* Environment Variable Assignments.

	   Example Syntax: "FOO=BAR HELLO=WO${RLD}" becomes:
	   1. An Array with two items (2 assignments), each item is an object.
	   2. The single key in each object is the name of the variable
	      (a literal string, never expanded)
	   3. The value of each key is a Token Array (possibly compounded token list).

	   [
	     {
	       "FOO": [ { "literal": "BAR" } ]
	     },
	     {
	       "HELLO": [
	           { "literal": "WO" },
	           { "envvar": "USER" }
	        ]
	     }
	   ]
	*/
	function DescribeAssignments(obj)
	{
		VerifyArray(obj);
		var results = [] ;
		obj.forEach(function(item){
			var varname = GetOneKey(item); //Name of the ENV variable to set.
			var value_token = item[varname]; //Value of the variable
			var value = DescribeToken(false,value_token); //Expand the value, if needed

			var desc = varname + "=" + value ;
			results.push(desc);
		});
		return results.join(" ");
	}

	function DescribeRedirections(obj)
	{
		//TODO: generate descriptive string from redirection structure
		return "";
	}


	/* Describe an environment variable.
	   When executed/emulated, the function should return the actual content of the variable. */
	function DescribeEnvVar(obj)
	{
		return '${' + obj + '}';
	}

	/* Describe an operation on an environment variable (e.g. ${FOO:-BAR} ).
	   When executed/emulated, the function should return the actual content of the variable,
	   after performing the requested operation on it.

	   Example: the following operation: ${FOO:=HELLO$(uname -s)}
	   is represented by the following structure:
	   1. "envvar"    - the name of the variable. never expanded.
	   2. "operation" - as described in section "2.6.2 Parameter expansion"
	   3. "value"     - a token to assign. Could be a compounded Token, needs to
	                    be recursively evalutated.
	*/
	function DescribeEnvVarOperation(obj)
	{
		VerifyAllowedKeys(obj, ["envvar","operation","value"]);

		var varname = obj["envvar"];
		//TODO: when exeuting/emulating, get the content (if any)
		//	of "varname".

		var operation = obj["operation"];

		//TODO: when executing/emulating, calculate the content of
		//	the value.
		var value = "";
		/* "value" is optional - e.g. no "value" in  ${FOO=} */
		if (obj["value"]) {
			value = DescribeToken(true,obj["value"]);
		}

		//TODO: when executing/emulating, set the returned value
		//	based on the varname+operation+value.

		return '${' + varname + operation + value + '}';
	}

	/* Single Quoted Strings are just like literals */
	function DescribeSingleQuotes(obj)
	{
		return "'" + obj + "'" ;
	}

	/* DoubleQuotes are very similar to generic tokens,
	   with the exception of no Filename-Expansion,
	   and the special handling of "@".
	   See section "2.2.3 Double-Quotes" */
	function DescribeDoubleQuotes(obj)
	{
		var desc = DescribeToken(true,obj);
		return '"' + desc + '"' ;
	}


	/* SubShells contains Commands.
	   During Executing/Emulation, a new Shell Execution Environment
	   needs to be established.
	*/
	function DescribeSubshell(obj)
	{
		/* NOTE: This can happen with an empty subshell, e.g.: "echo $()" */
		if (obj === null)
			return "$()";
		var desc = DescribeCommand(obj);
		return "$(" + desc + ")";
	}

	/* Backtick-shells contains Commands.
	   During Executing/Emulation, a new Shell Execution Environment
	   needs to be established.
	*/
	function DescribeBacktickShell(obj)
	{
		/* NOTE: This can happen with an empty subshell, e.g.: "echo $()" */
		if (obj === null)
			return "``";
		var desc = DescribeCommand(obj);
		return "`" + desc + "`";
	}

	/* Process an list of arithmetics operation, with the same precedence
	   (eg. a list of addition/substractions, or a list of multiplications/divisions).
	   During execution/emulation, 'value' should contain the accumulated value */
	function DescribeArithmeticOpList(obj)
	{
		VerifyArray(obj);
		var operand = obj[0];
		var value = DescribeArithmeticExpression(operand);
		var i = 1 ;
		while (i<obj.length) {
			var operator = obj[i];
			var operand2 = obj[i+1];
			i += 2;
			value = value + operator + DescribeArithmeticExpression(operand2);
		}
		return value;
	}

	/* Arithmetics */
	function DescribeArithmeticExpression(obj)
	{
		var op = GetOneKey(obj);
		var value = obj[op];
		switch (op)
		{
		case 'literal':
			return value; //TODO: convert to numeric?

		/*TODO: when executing/emulating, fetch the value.
		  NOTE: this always returns an envvar wrapped in ${}, even
		        if the input syntax was not wrapped. These are functionally
		        equivalent: $((A+4))  $((${A}+4)) */
		case 'envvar':
			return DescribeEnvVar(value);

		case 'arithmetics_op_list':
			return DescribeArithmeticOpList(value);

		case 'arithmetic':
			return DescribeArithmeticExpression(value);

		case 'subshell':
			return DescribeSubshell(value);

		default:
			throw "Uknown arithmetic operation '" + op + '"';
		}
	}

	function DescribeArithmetic(obj)
	{
		return "$((" + DescribeArithmeticExpression(obj) + "))";
	}

	/* Process Token or Tokens, with variable expansion.
	   This step corresponds to POSIX Shell Secion 2.1 "Shell Introduction" item #4,
	   and section "2.6 Word Expansions".

	   NOTE: The number of input elements DOES NOT necessarily corresponds to
		 number of output elements - see item #2 "field splitting" in Section "2.6 Word Expansions".

	   Example:
	   The following Token:  H"EL"L'O'${FOO-WO}$(echo rld)$((5*$(id -u)))
	   is represented by the following structure:
	    [
	      { "literal": "H" },
	      { "doublequotedstring": "EL" },
	      { "literal": "LO" },
	      {
	        "envvar_operation": {
	          "value": [ "WO" ],
	          "operation": "-",
	          "envvar": "FOO"
	        }
	      },
	      { "subshell": [ "echo rld" ] },
	      { "arithmetic": {
	          "arithmetics_mul_div": [
	            { "literal": 5 },
	            "*",
	            { "subshell": [ "id -u" ] }
	          ]
	        }
	      }
	    ]

	    This module only describes tokens, so there's no need to execute commands
	    (e.g. "id -u", or arithmetics calculations in the above example).
	*/
	function DescribeToken(allow_multiple_fields,obj)
	{
		var results = [] ;
		VerifyBoolean(allow_multiple_fields);
		VerifyArray(obj);
		obj.forEach(function(item){
			var token_type = GetOneKey(item);
			var token_value = item[token_type];
			var desc = "" ;
			switch(token_type)
			{
			case "literal":
				desc = token_value;
				break;

			case "delimiter":
				desc = " ";
				break;

			case "singlequotedstring":
				desc = DescribeSingleQuotes(token_value);
				break;

			case "doublequotedstring":
				desc = DescribeDoubleQuotes(token_value);
				break;

			case 'envvar_operation':
				desc = DescribeEnvVarOperation(token_value);
				break;

			case 'envvar':
				desc = DescribeEnvVar(token_value);
				break;

			case 'arithmetic':
				desc = DescribeArithmetic(token_value);
				break;

			case 'subshell':
				desc = DescribeSubshell(token_value);
				break;

			case 'backtickshell':
				desc = DescribeBacktickShell(token_value);
				break;

			default:
				throw "Unknown Posix-Shell-Token '" + token_type + '"';
			}
			results.push(desc);
		});

		/* TODO: field splitting */
		/* TODO: if 'allow_multiple_fields' === false,
			 and after field-splitting we do have multiple fields - throw an error */
		return results.join("");
	}

	function DescribeSimpleCommand(obj)
	{
		VerifyAllowedKeys(obj, ["command","redirections","assignments"]);

		var assignment_desc = "" ;
		var tokens_desc = "" ;
		var redirection_desc = "" ;
		if ("assignments" in obj)
			assignment_desc = DescribeAssignments( obj["assignments"] ) + " " ;
		if ("redirections" in obj)
			redirection_desc = " " + DescribeRedirections( obj["redirections"] );
		if ("command" in obj)
			tokens_desc = DescribeToken( true, obj["command"] );

		var v =  assignment_desc + tokens_desc + redirection_desc ;
		v = v.replace(/ *$/,"");
		v = v.replace(/^ */,"");
		return v;
	}

	function DescribeAndOrList(obj)
	{
		VerifyArray(obj);
		var cmd = obj[0];
		var list_desc = DescribeCommand(cmd);
		var i = 1 ;
		while (i<obj.length) {
			var condition = obj[i];
			var cmd = obj[i+1];
			i += 2;
			list_desc = list_desc + " " + condition + " " + DescribeCommand(cmd);
		}
		return list_desc;
	}

	function DescribePipeline(obj)
	{
		VerifyArray(obj);
		var pipe_desc = obj.map(DescribeCommand).join(" | ");
		return pipe_desc ;
	}

	function DescribeList(obj)
	{
		var result = "" ;
		VerifyArray(obj);
		obj.forEach(function(item){
			var exec_type = GetOneKey(item);
			var exec_char = "" ;
			switch (exec_type)
			{
			case "foreground":
				exec_char = " ;";
				break;
			case "background":
				exec_char += " &";
				break;
			default:
				throw "Invalid list exec-type '" + exec_type + "', expecting 'foreground' or 'background'" ;
			}

			var command = DescribeCommand( item[exec_type] );

			result += command + exec_char ;
		});

		/* TODO: if the last terminator is ";" - it can be ommited */
		result = result.replace(/; *$/,"");
		return result;
	}


	function DescribeCommand(obj)
	{
		VerifyAllowedKeys(obj, ["SimpleCommand","and_or_list","list","pipeline"]);
		var type = GetOneKey(obj);
		var value = obj[type];
		switch (type)
		{
		case "SimpleCommand":
			return DescribeSimpleCommand(value);
		case "and_or_list":
			return DescribeAndOrList(value);
		case "list":
			return DescribeList(value);
		case "pipeline":
			return DescribePipeline(value);
		default:
			throw "Invalid Command type '" + type + '"';
		}
	}

	return {
		"DescribeShellCommand" : DescribeCommand
		};
})();

//Ugly Hack: make it global
DescribeShellCommand = Shell_Descriptor.DescribeShellCommand;
