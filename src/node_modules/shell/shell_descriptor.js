/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/

/*
   This module iterates over a Shell-Parse-Tree (as generated by 'posix_shell.pegjs'),
   and produces a one-line text description of the command (akin to "toString()).

   This module can be considered as the reference implementation and verifier
   of the parse-tree object structure and hierarchy produced by 'posix_shell.pegjs'.

   This module requires the functions from 'utils.js' to be loaded.

   Usage Example:
	require("utils.js");
	require("posix_shell.js")
	require("shell_descriptor.js");

	// Any shell command line
	var shell_command = "FOO=BAR seq 10 | wc -l && true || echo fail" ;

	// ParseTree is JSON object, representing the shell command
	var ParseTree = posix_shell_parser.parse(shell_command);

	// description should be (very) similar to the original 'shell_command' .
	// (There will be differences in white space, and redirections order.)
	var description = DescribeShellCommand(ParseTree);

 */
Shell_Descriptor = (function() {

	/* Environment Variable Assignments.

	   Example Syntax: "FOO=BAR HELLO=WO${RLD}" becomes:
	   1. An Array with two items (2 assignments), each item is an object.
	   2. The single key in each object is the name of the variable
	      (a literal string, never expanded)
	   3. The value of each key is a Token Array (possibly compounded token list).

	   [
	     {
	       "FOO": [ { "literal": "BAR" } ]
	     },
	     {
	       "HELLO": [
	           { "literal": "WO" },
	           { "envvar": "USER" }
	        ]
	     }
	   ]
	*/
	function DescribeAssignments(obj)
	{
		VerifyArray(obj);
		var results = [] ;
		obj.forEach(function(item){
			var varname = GetOneKey(item); //Name of the ENV variable to set.
			var value_token = item[varname]; //Value of the variable
			var value = DescribeToken(false,value_token); //Expand the value, if needed

			var desc = varname + "=" + value ;
			results.push(desc);
		});
		return results.join(" ");
	}

	function DescribeRedirections(obj)
	{
		//TODO: generate descriptive string from redirection structure
		return "";
	}


	/* Describe an environment variable.
	   When executed/emulated, the function should return the actual content of the variable. */
	function DescribeEnvVar(obj)
	{
		return '${' + obj + '}';
	}

	/* Describe an operation on an environment variable (e.g. ${FOO:-BAR} ).
	   When executed/emulated, the function should return the actual content of the variable,
	   after performing the requested operation on it.

	   Example: the following operation: ${FOO:=HELLO$(uname -s)}
	   is represented by the following structure:
	   1. "envvar"    - the name of the variable. never expanded.
	   2. "operation" - as described in section "2.6.2 Parameter expansion"
	   3. "value"     - a token to assign. Could be a compounded Token, needs to
	                    be recursively evalutated.
	*/
	function DescribeEnvVarOperation(obj)
	{
		VerifyAllowedKeys(obj, ["envvar","operation","value"]);

		var varname = obj["envvar"];
		//TODO: when exeuting/emulating, get the content (if any)
		//	of "varname".

		var operation = obj["operation"];

		//TODO: when executing/emulating, calculate the content of
		//	the value.
		var value = DescribeToken(obj["value"]);

		//TODO: when executing/emulating, set the returned value
		//	based on the varname+operation+value.

		return '${' + varname + operation + value + '}';
	}

	/* Process Token or Tokens, with variable expansion.
	   This step corresponds to POSIX Shell Secion 2.1 "Shell Introduction" item #4,
	   and section "2.6 Word Expansions".

	   NOTE: The number of input elements DOES NOT necessarily corresponds to
		 number of output elements - see item #2 "field splitting" in Section "2.6 Word Expansions".

	   Example:
	   The following Token:  H"EL"L'O'${FOO-WO}$(echo rld)$((5*$(id -u)))
	   is represented by the following structure:
	    [
	      { "literal": "H" },
	      { "doublequotedstring": "EL" },
	      { "literal": "LO" },
	      {
	        "envvar_operation": {
	          "value": [ "WO" ],
	          "operation": "-",
	          "envvar": "FOO"
	        }
	      },
	      { "subshell": [ "echo rld" ] },
	      { "arithmetic": {
	          "arithmetics_mul_div": [
	            { "literal": 5 },
	            "*",
	            { "subshell": [ "id -u" ] }
	          ]
	        }
	      }
	    ]

	    This module only describes tokens, so there's no need to execute commands
	    (e.g. "id -u", or arithmetics calculations in the above example).
	*/
	function DescribeToken(allow_multiple_fields,obj)
	{
		var results = [] ;
		VerifyArray(obj);
		obj.forEach(function(item){
			var token_type = GetOneKey(item);
			var token_value = item[token_type];
			var desc = "" ;
			switch(token_type)
			{
			case "literal":
				desc = token_value;
				break;

			case "delimiter":
				desc = " ";
				break;

			case "doublequotedstring":
				// TODO: Handle parameter expansion INSIDE double quotes
				desc = '"' + token_value + '"';
				break;

			case 'envvar_operation':
				desc = DescribeEnvVarOperation(token_value);
				break;

			case 'envvar':
				desc = DescribeEnvVar(token_value);
				break;

			case 'arithmetic':
				desc = DescribeArithmetic(token_value);
				break;
			}

			results.push(desc);
		});

		/* TODO: field splitting */
		/* TODO: if 'allow_multiple_fields' === false,
			 and after field-splitting we do have multiple fields - throw an error */
		return results.join("");
	}

	function DescribeSimpleCommand(obj)
	{
		var cmd = obj["SimpleCommand"];
		VerifyAllowedKeys(cmd, ["command","redirections","assignments"]);

		var assignment_desc = "" ;
		var tokens_desc = "" ;
		var redirection_desc = "" ;
		if ("assignments" in cmd)
			assignment_desc = DescribeAssignments( cmd["assignments"] ) + " " ;
		if ("redirections" in cmd)
			redirection_desc = " " + DescribeRedirections( cmd["redirections"] );
		if ("command" in cmd)
			tokens_desc = DescribeToken( true, cmd["command"] );

		var v =  assignment_desc + tokens_desc + redirection_desc ;
		v = v.replace(/ *$/,"");
		v = v.replace(/^ */,"");
		return v;
	}

	function DescribeAndOrList(obj)
	{
		var list = obj["and_or_list"];
		VerifyArray(list);
		var cmd = list[0];
		var list_desc = DescribeCommand(cmd);
		var i = 1 ;
		while (i<list.length) {
			var condition = list[i];
			var cmd = list[i+1];
			i += 2;
			list_desc = list_desc + " " + condition + " " + DescribeCommand(cmd);
		}
		return list_desc;
	}

	function DescribePipeline(obj)
	{
		var pipeline = obj["pipeline"];
		VerifyArray(pipeline);
		var pipe_desc = pipeline.map(DescribeCommand).join(" | ");
		return pipe_desc ;
	}

	function DescribeList(obj)
	{
		var result = "" ;
		var list = obj["list"];
		VerifyArray(list);
		for (var i in list) {
			var item = list[i];
			var exec_type = GetOneKey(item);
			var command = DescribeCommand( item[exec_type] );

			if (result.length>0)
				result = result + " ";

			result += command ;
			switch (exec_type)
			{
			case "foreground":
				result += " ;";
				break;
			case "background":
				result += " &";
				break;
			default:
				throw "Invalid list exec-type '" + exec_type + "', expecting 'foreground' or 'background'" ;
			}
		}

		/* TODO: if the last terminator is ";" - it can be ommited */
		result = result.replace(/; *$/,"");
		return result;
	}


	function DescribeCommand(obj)
	{
		VerifyAllowedKeys(obj, ["SimpleCommand","and_or_list","list","pipeline"]);
		if ( "SimpleCommand" in obj )
			return DescribeSimpleCommand(obj)
		else if ( "and_or_list" in obj )
			return DescribeAndOrList(obj)
		else if ( "list" in obj )
			return DescribeList(obj)
		else if ( "pipeline" in obj )
			return DescribePipeline(obj)
	}

	return {
		"DescribeShellCommand" : DescribeCommand
		};
})();

//Ugly Hack: make it global
DescribeShellCommand = Shell_Descriptor.DescribeShellCommand;
