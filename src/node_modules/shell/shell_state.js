/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/
"use strict";

/*
This module deals with the Shell's internal state variables,
and the shell's Special Built-in Utilities.

More information:

POSIX Shell
http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_14

POSIX Shell, Section 2.14 - Special Build-in Utitlities
http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_14

List of Special Built-in Utilities
http://pubs.opengroup.org/onlinepubs/009695399/idx/sbi.html


TODO:
1. There's an interplay between UNSET and EMPTY variables, which is not (yet)
correctly implemented.
e.g.
   unset CCC
   export CCC
   export -p | grep CCC   => CCC exists, but has no value and no "=".


2. Exporting variables from the 'current' shell into the process_state is not yet
implemented.
*/

var ob_utils = require('utils/object_utils');
var str_utils = require('utils/string_utils');
var ProcessState = require('os/process_state');

module.exports = ShellState;

/* Single-letter shell options,
 *  * see http://pubs.opengroup.org/onlinepubs/009695399/utilities/set.html */
var single_letter_options = {
	"a" : "allexport",
	"C" : "noclobber",
	"e" : "errexit",
	"f" : "noglob",
	"n" : "noexec",
	"m" : "monitor",
	"b" : "notify",
	"u" : "nounset",
	"v" : "verbose",
	"x" : "xtrace" };

function ShellState()
{
	this.interactive = false;

	this.options = {
		errexit: false,
		noglob: false,
		ignoreeof: false,
		interactive: false,
		monitor: false,
		noexec: false,
		stdin: false,
		xtrace: false,
		verbose: false,
		vi: false,
		emacs: false,
		noclobber: false,
		allexport: false,
		notify: false,
		nounset: false,
		nolog: false,
		debug: false
	};

	//TODO: store functions here as well?
	this.variables = {} ;
}

ShellState.prototype.isSpecialBuiltinUtility=function(name)
{
	switch(name)
	{
	case "break":
	case ":":
	case "continue":
	case ".":
	case "eval":
	case "exec":
	case "exit":
	case "export":
	case "readonly":
	case "return":
	case "set":
	case "shift":
	case "times":
	case "trap":
	case "unset":
		return true;
	default:
		return false;
	}
}

ShellState.prototype.runSpecialBuiltinUtility=function(process_state,argv)
{
	if (!(process_state instanceof ProcessState))
		throw new TypeError("process_state is not a ProcessState class");
	ob_utils.VerifyArray(argv);

	var name = argv.shift();
	switch(name)
	{
	case ":":
		return this.colon(process_state,argv);

	case "set":
		return this.set(process_state,argv);

	case "export":
		return this._export(process_state,argv);

	case "readonly":
		return this.readonly(process_state,argv);

	case "unset":
		return this.unset(process_state,argv);

	default:
		process_state.stderr.put_line("Agnostic Shell Error: Special built-it utility '" + name + "' is not yet implemented");
		return 1;
	}
}

/*
The Colon (NULL) utility
http://pubs.opengroup.org/onlinepubs/009695399/utilities/colon.html

*/
ShellState.prototype.colon = function(process_state,argv)
{
	return 0;
}

/*
The Set utility
http://pubs.opengroup.org/onlinepubs/009695399/utilities/set.html
*/
ShellState.prototype.set = function(process_state,argv)
{
	// No options - print all variables
	if (argv.length===0)
		return this.set_print_vars(process_state);

	if (argv.length===1 && argv[0]==="-o")
		return this.set_print_settings(process_state, false);

	if (argv.length===1 && argv[0]==="+o")
		return this.set_print_settings(process_state, true);

	process_state.stderr.put_line("Emulation error: set not fully implemented yet");
	return 1;
}


ShellState.prototype.set_print_vars = function(process_state)
{
	var varnames = Object.keys(this.variables);
	varnames.sort();
	for (var i in varnames) {
		var varname = varnames[i];
		var value = this.variables[varname].value;
		//TODO: Shell-Qutoes for 'value'
		process_state.stdout.put_line(varname + "='" + value + "'");
	}
	return 0;
}

ShellState.prototype.set_print_settings = function(process_state,strict_format)
{
	for (var option in this.options) {
		var value = this.options[option];
		var msg;
		if (strict_format)
			msg = "set " + ((value)?"-o ":"+o ") + option;
		else
			msg = option + "\t\t" + (value?"on":"off");
		process_state.stdout.put_line(msg);
	}
	return 0;
}


/*
The Export Utility
http://pubs.opengroup.org/onlinepubs/009695399/utilities/export.html
*/
ShellState.prototype._export = function(process_state,argv)
{
	// No options - print all exported variables
	if (argv.length===0 ||
	    (argv.length===1 && argv[0] === "-p" ))
		return this.export_print_vars(process_state);

	//Otherwise, each option is a variable (and possible assignment)
	for (var i in argv) {
		var item = str_utils.parse_var_assignment(argv[i]);

		if (!item.valid) {
			process_state.stderr.put_line("export: '" + argv[i] +
						"': not a valid identifier");
			return 1;
		}

		//If there's assignment, set the variable first
		if (item.assignment) {
			if (this.variable_set(process_state,item.name,item.value)!=0)
				return 1;
		}

		//Mark the variable as exported
		this.variable_mark_exported(process_state,item.name);
	}
	return 0;
}

ShellState.prototype.export_print_vars = function(process_state)
{
	var varnames = Object.keys(this.variables);
	varnames.sort();
	for (var i in varnames) {
		var varname = varnames[i];
		var exported = this.variables[varname].exported;
		if (!exported)
			continue;
		var value = this.variables[varname].value;
		//TODO: Shell-Qutoes for 'value'
		process_state.stdout.put_line("export " + varname + "='" + value + "'");
	}
	return 0;
}

ShellState.prototype.get_exported_variables = function()
{
	var result = {} ;
	var varnames = Object.keys(this.variables);
	varnames.sort();
	for (var i in varnames) {
		var varname = varnames[i];
		var exported = this.variables[varname].exported;
		if (!exported)
			continue;
		var value = this.variables[varname].value;
		result[varname] = value;
	}
	return result;
}

/*
The Readonly Utility
http://pubs.opengroup.org/onlinepubs/009695399/utilities/readonly.html
*/
ShellState.prototype.readonly = function(process_state,argv)
{
	// No options - print all exported variables
	if (argv.length===0 ||
	    (argv.length===1 && argv[0] === "-p" ))
		return this.readonly_print_vars(process_state);

	//Otherwise, each option is a variable (and possible assignment)
	for (var i in argv) {
		var item = str_utils.parse_var_assignment(argv[i]);

		if (!item.valid) {
			process_state.stderr.put_line("readonly: '" + argv[i] +
						"': not a valid identifier");
			return 1;
		}

		//If there's assignment, set the variable first
		if (item.assignment) {
			if (this.variable_set(process_state,item.name,item.value)!=0)
				return 1;
		}

		//Mark the variable as exported
		this.variable_mark_readonly(process_state,item.name);
	}
	return 0;
}

ShellState.prototype.readonly_print_vars = function(process_state)
{
	var varnames = Object.keys(this.variables);
	varnames.sort();
	for (var i in varnames) {
		var varname = varnames[i];
		var readonly = this.variables[varname].readonly;
		if (!readonly)
			continue;
		var value = this.variables[varname].value;
		//TODO: Shell-Qutoes for 'value'
		process_state.stdout.put_line("readonly " + varname + "='" + value + "'");
	}
	return 0;
}

/*
The unset Utility
http://pubs.opengroup.org/onlinepubs/009695399/utilities/unset.html
*/
ShellState.prototype.unset = function(process_state,argv)
{
	// No options - do nothing
	if (argv.length===0)
		return 0;

	//Otherwise, each option is a variable (and possible assignment)
	for (var i in argv) {
		var varname = argv[i];
		if (!str_utils.valid_varname(varname))	{
			process_state.stderr.put_line("Agnostic Shell: variable '" + varname + "' is read-only");
			//TODO: throw exception and terminate shell?
			return 1;
		}
		this.variable_unset(process_state,varname);
	}
	return 0;
}

/*****************************************************
     Variable Related functions
*****************************************************/

ShellState.prototype.variable_get = function(process_state,varname)
{
	ob_utils.VerifyString(varname);
	if (!str_utils.valid_varname(varname))
		throw TypeError("Invalid variable name '" + varname + "'");

	//TODO:
	//Handle special variables (e.g. $! / $#, $1/$2/$3 ...)
	if (varname in this.variables) {
		return this.variables[varname].value;
	}

	// Variable not found - return empty unless 'nounset' option is on
	if (!this.options.nounset)
		return "";

	process_state.stderr.put_line("Agnostic Shell: variable '" + varname + "' not set");

	//TODO:
	//If non-interactive, throw an error to terminal the shell.
	return "";
}

/* Returns TRUE if the variable exists and is marked read-only. */
ShellState.prototype.variable_is_readonly = function(varname)
{
	ob_utils.VerifyString(varname);
	var b = ( (varname in this.variables) &&
		 (this.variables[varname].readonly) );
	return b;
}

ShellState.prototype.variable_set = function(process_state,varname,value)
{
	ob_utils.VerifyString(varname);
	if (!str_utils.valid_varname(varname))
		throw TypeError("Invalid variable name '" + varname + "'");

	if (this.variable_is_readonly(varname)) {
		process_state.stderr.put_line("Agnostic Shell: variable '" + varname + "' is read-only");
		//TODO: throw exception and terminate shell?
		return 1;
	}

	// if exists, just update it's value
	if (varname in this.variables) {
		this.variables[varname].value = value;
	} else {
		//new variable, create it
		this.variables[varname] = {
				value: value,
				readonly: false,
				exported: this.options.allexport,
			};
	}

	// Export if needed
	if (this.options.allexport || this.variables[varname].exported) {
		//TODO: implement exporting,
		//by updateding the process_state's ENV ?
	}
	return 0;
}

ShellState.prototype.variable_unset = function(process_state,varname)
{
	ob_utils.VerifyString(varname);
	if (!str_utils.valid_varname(varname))
		throw TypeError("Invalid variable name '" + varname + "'");

	//Unsetting a non-existing variable is not an error.
	if ( !(varname in this.variables) )
		return 0;

	if (this.variable_is_readonly(varname)){
		process_state.stderr.put_line("Agnostic Shell: variable '" + varname + "' is read-only");
		//TODO: throw exception and terminate shell?
		return 1;
	}

	// Un-Export if needed
	if (this.options.allexport || this.variables[varname].exported) {
		//TODO: implement Un-Exporting,
		//by updateding the process_state's ENV ?
	}

	//TODO:
	//  Should we delete the variabe, or add 'unset' attribute?
	//  there seems to be a possibility of a read-only UNSET variable.
	delete this.variables[varname];

	return 0;
}

ShellState.prototype.variable_mark_readonly = function(process_state,varname)
{
	ob_utils.VerifyString(varname);
	if (varname==="")
		throw TypeError("varname is empty");

	if ( !(varname in this.variables) )
		throw TypeError("varname '" + varname + "' does not exist");

	this.variables[varname].readonly = true;
}

ShellState.prototype.variable_mark_exported = function(process_state,varname)
{
	ob_utils.VerifyString(varname);
	if (varname==="")
		throw TypeError("varname is empty");

	if ( !(varname in this.variables) )
		throw TypeError("varname '" + varname + "' does not exist");

	this.variables[varname].exported = true;
}

