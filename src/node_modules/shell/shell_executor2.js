/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/

/*
   This module iterates over a Shell-Parse-Tree (as generated by 'posix_shell.pegjs'),
   and produces a one-line text description of the command (akin to "toString()).

   This module can be considered as the reference implementation and verifier
   of the parse-tree object structure and hierarchy produced by 'posix_shell.pegjs'.

   This module requires the functions from 'utils.js' to be loaded.

   Usage Example:
	require("utils.js");
	require("posix_shell.js")
	require("shell_descriptor.js");

	// Any shell command line
	var shell_command = "FOO=BAR seq 10 | wc -l && true || echo fail" ;

	// ParseTree is JSON object, representing the shell command
	var ParseTree = posix_shell_parser.parse(shell_command);

	// description should be (very) similar to the original 'shell_command' .
	// (There will be differences in white space, and redirections order.)
	var description = DescribeShellCommand(ParseTree);

 */

require('utils/shell_quotes');

ShellExecutor = function(shell_process_state, external_programs) {

/* See section "2.9.1 Simple Commands, subsection "Command Search and Execution", item '1.a',
   and
   "2.14 Special Build-In Utilities".

NOTE:
See section "2.14" for the difference between
"Special Built-in Utilities" and (non-special) "Built-In utilities"
 */
function isSpecialBuiltinUtility(cmd)
{
	var special_builtin_commands = { "break" : 1,
				  ":" : 1, // the 'colon' NULL utility
				  "continue" : 1,
				  "." : 1, // the 'dot'/SOURCE command
				  "eval" : 1,
				  "exec" : 1,
				  "exit" : 1,
				  "export": 1,
				  "readonly" : 1,
				  "return" : 1,
				  "set" : 1,
				  "shift" : 1,
				  "times" : 1,
				  "trap" : 1,
				  "unset" : 1 };
	return (cmd in special_builtin_commands);
}

/* See section "2.9.1 Simple Commands, subsection "Command Search and Execution", item '1.c' */
function isBuiltinUtility(cmd)
{
	var builtin_commands = { "alias" : 1,
				 "bc" : 1,
				 "cd" : 1,
				 "command" : 1,
				 "false" : 1,
				 "fc" : 1,
				 "fg" : 1,
				 "getopts" : 1,
				 "jobs" : 1,
				 "kill" : 1,
				 "newgrp" : 1,
				 "pwd" : 1,
				 "read" : 1,
				 "true" : 1,
				 "umask" : 1,
				 "unalias" : 1,
				 "Wait" : 1 };

	return (cmd in builtin_commands);
}

/* See section "2.9.1 Simple Commands, subsection "Command Search and Execution", item '1':
returns TRUE if the command DOES NOT have a slash. */
function isNoSlash(cmd)
{
	return (cmd.indexOf("/")==-1);
}


/* run an external command, as if it is found in $PATH */
function runExternalCommand(process_state,tokens)
{
	var command_name = tokens[0];

	if ( !(command_name in external_programs) ) {
		throw "Shell Error: command not found: " + command_name ;
	}

	var prog_obj = new external_programs[command_name]();
	var exit_code = prog_obj.run(process_state,tokens);
	return exit_code;
}

/* Execute a Command-Tree (as generated by the POSIX-Shell parser */
function ExecCommandTree(obj)
{
	return Command(shell_process_state,obj);
}

/*
Command() - The starting point of Shell-Syntax-Tree parsing.
*/
function Command(process_state, obj)
{
	var type = GetOneKey(obj);
	var value = obj[type];
	switch (type)
	{
	case "SimpleCommand":
		return SimpleCommand(process_state,value);
	case "and_or_list":
		return AndOrList(process_state, value);
	case "list":
		return List(process_state,value);
	case "pipeline":
		return Pipeline(value);
	case "compound_subshell":
		return CompoundSubshell(value);
	case "compound_currentshell":
		return CompoundCurrentshell(value);
	default:
		throw "Invalid Command type '" + type + '"';
	}
}

/*
Pipeline() - process commands in a pipeline (e.g. "seq 10 | wc -l").

$ ./parse 'foo|bar|baz'
{
  "pipeline": [
    { "SimpleCommand": { "command": [ { "literal": "foo" } ] } },
    { "SimpleCommand": { "command": [ { "literal": "bar" } ] } },
    { "SimpleCommand": { "command": [ { "literal": "baz" } ] } }
  ]
}

During Execution:
1. Run command
2. Get STDOUT of last command, use it as STDIN for next command
*/
function Pipeline(obj)
{
	VerifyArray(obj);
	var pipe_desc = obj.map(Command).join(" | ");
	return pipe_desc ;
}

/*
List() - process commands line a sequential (or background) list
         (e.g. "true ; sleep 60 & false ;")o

$ ./parse 'foo ; bar & baz'
{
  "list": [
    {
      "foreground": {
        "SimpleCommand": { "command": [ { "literal": "foo" } ] }
      }
    },
    {
      "background": {
        "SimpleCommand": { "command": [ { "literal": "bar" } ] }
      }
    },
    {
      "foreground": {
        "SimpleCommand": { "command": [ { "literal": "baz" } ] }
      }
    }
  ]
}

During Execution:
1. Run each command.
2. Commands share STDIN/STDOUT/STDERR (unless redirected for each command).
3. Since it is not likely "background" execution will be emulated here,
   even background commands will be executed sequentially in foreground.
*/
function List(process_state, obj)
{
	var exit_code = 0 ;
	VerifyArray(obj);
	obj.forEach(function(item){
		var exec_type = GetOneKey(item); //type = foreground/background

		//In this emulation, all commands are executed in foreground,
		//the background operator '&' has no effect.
		exit_code  = Command( process_state, item[exec_type] );
	});
	return exit_code;
}


/*
AndOrList() - Process commands in an And/Or list
              (e.g. "true && echo ok || echo fail")

$ ./parse 'true && foo || bar'
{
  "and_or_list": [
    {
      "SimpleCommand": { "command": [ { "literal": "true" } ] }
    },
    "&&",
    {
      "SimpleCommand": { "command": [ { "literal": "foo" } ] }
    },
    "||",
    {
      "SimpleCommand": { "command": [ { "literal": "bar" } ] }
    }
  ]
}

During Execution:
1. Run the first command.
2. The the following commands depending on the previous exitcode
   and the operation (&& or ||)
*/
function AndOrList(process_state, obj)
{
	var exit_code = 0 ;
	VerifyArray(obj);
	var cmd = obj[0];
	exit_code = Command(process_state, cmd);
	var i = 1 ;
	while (i<obj.length) {
		var condition = obj[i];
		var cmd = obj[i+1];
		i += 2;
		if (
			(condition === "&&" && exit_code ===0)
			||
			(condition === "||" && exit_code !==0)
		   ) {
			exit_code = Command(process_state, cmd);
		}
	}
	return exit_code ;

}
/*
SimpleCommand() - Process a single execution command,
                  (e.g. equivalent to a single program to run, a single call to 'exec()')

A Simple Command can contain each of the following:
1. Environment variable assignments
2. Command (i.e. program name, shell alias, shell function) + parameters
3. Redirections

Examples:

## No assignments or redirections here
$ ./parse 'seq 1 2 100'
{
  "SimpleCommand": {
    "command": [
      { "literal": "seq" },
      { "delimiter": null },
      { "literal": "1" },
      { "delimiter": null },
      { "literal": "2" },
      { "delimiter": null },
      { "literal": "100" }
    ]
  }
}

## Assignments and a command
$ ./parse 'CC=clang make'
{
  "SimpleCommand": {
    "command": [
      { "literal": "make" }
    ],
    "assignments": [
      {
        "CC": [ { "literal": "clang" } ]
      }
    ]
  }
}

## command and redirection
$ ./parse 'dmesg -c >/dev/null'
{
  "SimpleCommand": {
    "command": [
      { "literal": "dmesg" },
      { "delimiter": null },
      { "literal": "-c" }
    ],
    "redirections": [
      {
        "filedescriptor": 1,
        "forceclobber": false,
        "filename": [ { "literal": "/dev/null" }
        ],
        "type": "output_file"
      }
    ]
  }
}

Valid Simple-Commands can contain either of the above three - that is,
A Simple-Command with only Environment-Variable-Assignment is valid (it only
changes the shell's variables without executing any program).

See section "2.9.1 Simple Commands" for details, and IMPORTANT notes
about processing order of assignment/redirection/execution.

During Execution:
1. Perform Environment Variable assignment (if any)
2. Prepare redirections (if any)
3. Execute command (if any)
    3.1. "command" will be a list of tokens.
         After evaluation (and paramter expansion and field-splitting),
         the first element is considered the program to execute (or alias,function,etc.)
*/
function SimpleCommand(process_state, obj)
{
	VerifyAllowedKeys(obj, ["command","redirections","assignments"]);

	var exit_code = 0 ;

	//TODO: clone ProcessState, and setup redirection if needed.

	if ("assignments" in obj) {
		//TODO: do  Assignments( obj["assignments"] ) + " " ;
	}
	if ("redirections" in obj) {
		//TODO: do pre-exec redirections (reading STDIN) if needed.
		//	redirection_desc = " " + Redirections( obj["redirections"] );
	}
	if ("command" in obj) {
		// Execute command
		var tokens = Token( true, obj["command"] );

		// Should not happen, as the parser should detect and prevent it
		if (tokens.length === 0)
			throw "SimpleCommand: internal error, got empty 'command'";

		var command_name = tokens[0];
		if (isNoSlash(command_name)) {
			if (isSpecialBuiltinUtility(command_name)) {
				runSpecialBuiltinUtility(tokens);
			} else if (isBuiltinUtility(command_name)) {
				runBuiltinUtility(tokens);
			} else {
				exit_code = runExternalCommand(process_state,tokens);
			}
		} else {
			//Show error, we don't support running local executables
			//(there are no executables on disk in this emulation)
			throw "Agnostic Emulation error: executables with specific path are not supported (" + command_name + ")";
		}
	} else {
		// If the current SimpleCommand does not contain an actual command,
		// set any variable assignment to the current shell.
	}

	return exit_code;
}


/*
Assignments() - Process list of envrionment variable assignments.

Example:
$ ./parse 'FOO=BAR HELLO=WO${RLD}'
{
  "SimpleCommand": {
    "assignments": [
      {
        "FOO": [ { "literal": "BAR" } ]
      },
      {
        "HELLO": [
          { "literal": "WO" },
          { "envvar": "RLD" }
        ]
      }
    ]
  }
}

NOTE: Assignments are always a part of SimpleCommand.

During Execution:
1. Evaluation the value of each assignment
2. Set the value in the shell execution environment
*/
function Assignments(obj)
{
	VerifyArray(obj);
	var results = [] ;
	obj.forEach(function(item){
		var varname = GetOneKey(item); //Name of the ENV variable to set.
		var value_token = item[varname]; //Value of the variable
		var value = Token(false,value_token); //Expand the value, if needed

		var desc = varname + "=" + value ;
		results.push(desc);
	});
	return results.join(" ");
}

/*
Redirections() - Process list of redirections

NOTES:
1. Redirection on the command line can appear BEFORE
the actual command, with variable assignments (though this isn't common in practice).
2. The parser collects redirections (both before and after the command)
into one key 'redirections', though order is maintained.

Examples:
./parse '<input.txt wc -l >output.txt'
{
  "SimpleCommand": {
    "command": [
      { "literal": "wc" },
      { "delimiter": null },
      { "literal": "-l" }
    ],
    "redirections": [
      {
        "filedescriptor": 0,
        "filename": [ { "literal": "input.txt" } ],
        "type": "input_file"
      },
      {
        "filedescriptor": 1,
        "forceclobber": false,
        "filename": [ { "literal": "output.txt" } ],
        "type": "output_file"
      }
    ]
  }
}

*/
function Redirections(obj)
{
	//TODO: generate descriptive string from redirection structure
	VerifyArray(obj);
	return "";
}

/*
Token() - Process token(s).

Tokens are very close to WORD in the POSIX Shell document,
with some minor implementation-related differences.
Tokens can contain:
1. unquoted characters ( 'literals' )
2. delimiters (indicating a delimiter in the input string, but see below about
   field-splitting)
3. Double-Quoted strings (with possible parameter-expansion )
4. Subshells (e.g. $() )
5. Backtick-shells
6. Arithmetic expressions
7. Environment variables (e.g. $FOO and ${FOO} )
8. Environment variables with operations (e.g. ${FOO:-BAR} )

This step corresponds to POSIX Shell Secion 2.1 "Shell Introduction" item #4,
and section "2.6 Word Expansions".

NOTES:
1. The number of input elements DOES NOT necessarily corresponds to
number of output elements - see item #2 "field splitting" in Section "2.6 Word Expansions".
For example:
     C="me -s"
     una$C -r
Has one delimiter in the input string (between $C and -r),
but after field-splitting, the command will have three items: 'uname','-s','-r' .
2. Tokens appears as VALUES of many items (e.g. environemt variable assignment,
	redirection's filenames).

EXAMPLE:
(note that the "command" key points to an array, which is the Token):
$ ./parse 'H"EL"LO${FOO-WO}$(echo rld)$((5*$(id -u)))'
{
  "SimpleCommand": {
    "command": [
      { "literal": "H" },
      { "doublequotedstring": [ { "literal": "EL" } ] },
      { "literal": "LO" },
      { "envvar_operation": {
          "value": [ { "literal": "WO" } ],
          "operation": "-",
          "envvar": "FOO"
        }
      },
      {
        "subshell": {
          "SimpleCommand": {
            "command": [
              { "literal": "echo" },
              { "delimiter": null },
              { "literal": "rld" }
            ]
          }
        }
      },
      {
        "arithmetic": {
          "arithmetics_op_list": [
            { "literal": 5 },
            "*",
            {
              "subshell": {
                "SimpleCommand": {
                  "command": [
                    { "literal": "id" },
                    { "delimiter": null },
                    { "literal": "-u" }
                  ]
                }
              }
            }
          ]
        }
      }
    ]
  }
}


During Execution:
1.  This module only describes tokens, so there's no need to execute commands
    (e.g. "id -u", or arithmetics calculations in the above example).
*/
function Token(allow_multiple_fields,obj)
{
	var results = [] ;
	VerifyBoolean(allow_multiple_fields);
	VerifyArray(obj);
	obj.forEach(function(item){
		var token_type = GetOneKey(item);
		var token_value = item[token_type];
		var desc = "" ;
		switch(token_type)
		{
		case "literal":
			desc = token_value;
			break;

		case "delimiter":
			desc = " ";
			break;

		case "singlequotedstring":
			desc = SingleQuotedString(token_value);
			break;

		case "doublequotedstring":
			desc = DoubleQuotedString(token_value);
			break;

		case 'envvar_operation':
			desc = EnvVarOperation(token_value);
			break;

		case 'envvar':
			desc = EnvVar(token_value);
			break;

		case 'arithmetic':
			desc = Arithmetic(token_value);
			break;

		case 'subshell':
			//TODO: Take STDOUT of the program, and use it as token
			desc = Subshell(token_value);
			break;

		case 'backtickshell':
			//TODO: Take STDOUT of the program, and use it as token
			desc = BacktickShell(token_value);
			break;

		default:
			throw "Unknown Posix-Shell-Token '" + token_type + '"';
		}
		results.push(desc);
	});

	/* Join all sub-tokens */
	var str = results.join("");

	/* field splitting */
	var fields = [] ;
	if (allow_multiple_fields)
		fields = ShellQuotesSplit(str);
	else
		fields.push(str); //just one field, regardless of delimiters

	/* TODO: tilda/Filename expansion, if allowed */

	/*  quotes removal */
	for (var i in fields) {
		fields[i] = ShellQuotesRemoveQuotes(fields[i]);
	}

	return fields;
}




/*
EnvVar() - Process an environment variable, based on its name.

Example:
$ ./parse '$USER'
{
  "SimpleCommand": {
    "command": [
      {
        "envvar": "USER"
      }
    ]
  }
}

During Execution:
1. Return the content of the variable, based on the current shell execution environment
*/
function EnvVar(obj)
{
	return '${' + obj + '}';
}

/*
EnvVarOperation() - Process an environment variable with an operation
                    (e.g. "${FOO:=BAR}" or "${FOO%test$(id -u)}"

An environment variable operation is represented by the following structure:
1. "envvar"    - the name of the variable. never expanded.
2. "operation" - as described in section "2.6.2 Parameter expansion"
3. "value"     - a token to assign. Could be a compounded Token, needs to
	         be recursively evalutated.

NOTE:
1. "value" might be missing, if the input syntax was "${FOO=}".

Example:
$ ./parse '${FOO:-$(uname)}'
{
  "SimpleCommand": {
    "command": [
      {
        "envvar_operation": {
          "value": [
            {
              "subshell": {
                "SimpleCommand": {
                  "command": [ { "literal": "uname" } ]
                }
              }
            }
          ],
          "operation": ":-",
          "envvar": "FOO"
        }
      }
    ]
  }
}

During Execution:
1. Return the content of the variable, based on the current shell execution environment
*/
function EnvVarOperation(obj)
{
	VerifyAllowedKeys(obj, ["envvar","operation","value"]);

	var varname = obj["envvar"];
	//TODO: when exeuting/emulating, get the content (if any)
	//	of "varname".

	var operation = obj["operation"];

	//TODO: when executing/emulating, calculate the content of
	//	the value.
	var value = "";
	/* "value" is optional - e.g. no "value" in  ${FOO=} */
	if (obj["value"]) {
		value = Token(true,obj["value"]);
	}

	//TODO: when executing/emulating, set the returned value
	//	based on the varname+operation+value.

	return '${' + varname + operation + value + '}';
}

/*
SingleQuotedString() - just like a literal value.

Single Quoted Strings are just like literals */
function SingleQuotedString(obj)
{
	return "'" + obj + "'" ;
}

/*
DoubleQuotedString() - Evalutate tokens inside a double-quoted string.
In this implementation, a Double-Quoted String is similar to any other
compound token.
See section "2.2.3 Double-Quotes".

TODO
1. and the special handling of "@".

EXAMPLE:
$ ./parse 'echo "foo$((1+4))$baz"'
{
  "SimpleCommand": {
    "command": [
      { "literal": "echo" },
      { "delimiter": null },
      {
        "doublequotedstring": [
          { "literal": "foo" },
          { "arithmetic": {
              "arithmetics_op_list": [
                { "literal": 1 },
                "+",
                { "literal": 4 }
              ]
            }
          },
          { "envvar": "baz" }
        ]
      }
    ]
  }
}

*/
function DoubleQuotedString(obj)
{
	var desc = Token(true,obj);
	return '"' + desc + '"' ;
}


/*
Subshell() - Process a subshell execution.
The command to execute can be a full-fledged shell syntax command.

Example:
$ ./parse 'echo $(uname)'
{
  "SimpleCommand": {
    "command": [
      { "literal": "echo" },
      { "delimiter": null },
      {
        "subshell": {
          "SimpleCommand": { "command": [ { "literal": "uname" } ] }
        }
      }
    ]
  }
}

During Execution:
1. During Executing/Emulation, a new Shell Execution Environment needs to be established.
2. The STDIN of the existing shell should be passed to the subshell.
3. The STDOUT of this process should be returned as a token.
*/
function Subshell(obj)
{
	/* NOTE: This can happen with an empty subshell, e.g.: "echo $()" */
	if (obj === null)
		return "$()";
	var desc = Command(obj);
	return "$(" + desc + ")";
}

/*
BacktickShell() - Process a backtick subshell

Example:
$ ./parse 'echo `uname`'
{
  "SimpleCommand": {
    "command": [
      { "literal": "echo" },
      { "delimiter": null },
      {
        "backtickshell": {
          "SimpleCommand": { "command": [ { "literal": "uname" } ] }
        }
      }
    ]
  }
}


During Execution:
1. During Executing/Emulation, a new Shell Execution Environment needs to be established.
2. The STDIN of the existing shell should be passed to the subshell.
3. The STDOUT of this process should be returned as a token.

TODO:
Backtick-shells have some pecularities. Review the standard.
*/
function BacktickShell(obj)
{
	/* NOTE: This can happen with an empty subshell, e.g.: "echo $()" */
	if (obj === null)
		return "``";
	var desc = Command(obj);
	return "`" + desc + "`";
}

/*
CompoundSubshell() - Process a compound list of commands in a subshell.
                     (e.g.   "seq 10 | ( sed -u 1q ; sort -nr)" ).

NOTES:
See "2.9.4 Compound Commands" (http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_09_04),

During Execution:
1. The commands should get STDIN from current shell,
2. The commands should return STDOUT,STDERR to current shell
   (to be printed to console, or sent to next piped program)
*/
function CompoundSubshell(obj)
{
	return "(" + Command(obj) + ")";
}

/*
CompoundCurrentsshell() - Process a compound list of commands in current shell.
                     (e.g.   "false && { echo failed >&2 ; exit 1 ; }

NOTES:
See "2.9.4 Compound Commands" (http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_09_04),

During Execution:
1. The commands should get STDIN from current shell,
2. The commands should return STDOUT,STDERR to current shell
   (to be printed to console, or sent to next piped program)
*/
function CompoundCurrentshell(obj)
{
	return "{" + Command(obj) + " ; }";
}


/*
Arithmetic() - Process arithmetic parameter expansions (e.g. "$((5+4))" ).

NOTE:
1. Arithmetic Expressions can contain recursive parameter expansions (e.g
   environment variables, subshells, etc.).

Example:
$ ./parse '$((1+2*$(id -u)+42))'
{
  "SimpleCommand": {
    "command": [
      {
        "arithmetic": {
          "arithmetics_op_list": [
            { "literal": 1 },
            "+",
            {
              "arithmetics_op_list": [
                { "literal": 2 },
                "*",
                {
                  "subshell": {
                    "SimpleCommand": {
                      "command": [
                        { "literal": "id" },
                        { "delimiter": null },
                        { "literal": "-u" }
                      ]
                    }
                  }
                }
              ]
            },
            "+",
            { "literal": 42 }
          ]
        }
      }
    ]
  }
}

During Execution:
Return the integer value of the operation.

TODO:
1. implement all required arithmetic operations
*/
function Arithmetic(obj)
{
	return "$((" + ArithmeticExpression(obj) + "))";
}

/*
ArithmeticExpression() - Process the possible tokens in an arithmetic expression.

*/
function ArithmeticExpression(obj)
{
	var op = GetOneKey(obj);
	var value = obj[op];
	switch (op)
	{
	case 'literal':
		return value; //TODO: convert to numeric?

	/*TODO: when executing/emulating, fetch the value.
	  NOTE: this always returns an envvar wrapped in ${}, even
		if the input syntax was not wrapped. These are functionally
		equivalent: $((A+4))  $((${A}+4)) */
	case 'envvar':
		return EnvVar(value);

	case 'arithmetics_op_list':
		return ArithmeticOpList(value);

	case 'arithmetic':
		return ArithmeticExpression(value);

	case 'subshell':
		return Subshell(value);

	default:
		throw "Uknown arithmetic operation '" + op + '"';
	}
}


/* Process an list of arithmetics operation, with the same precedence
   (eg. a list of addition/substractions, or a list of multiplications/divisions).
   During execution/emulation, 'value' should contain the accumulated value */
function ArithmeticOpList(obj)
{
	VerifyArray(obj);
	var operand = obj[0];
	var value = ArithmeticExpression(operand);
	var i = 1 ;
	while (i<obj.length) {
		var operator = obj[i];
		var operand2 = obj[i+1];
		i += 2;
		value = value + operator + ArithmeticExpression(operand2);
	}
	return value;
}

	return {
		"ExecuteCommand" : ExecCommandTree
		};
};
