/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/
"use strict";

/*
   This module iterates over a Shell-Parse-Tree (as generated by 'posix_shell.pegjs'),
   and produces a one-line text description of the command (akin to "toString()).

   This module can be considered as the reference implementation and verifier
   of the parse-tree object structure and hierarchy produced by 'posix_shell.pegjs'.

   This module requires the functions from 'utils.js' to be loaded.

   Usage Example:
	require("utils.js");
	require("posix_shell.js")
	require("shell_descriptor.js");

	// Any shell command line
	var shell_command = "FOO=BAR seq 10 | wc -l && true || echo fail" ;

	// ParseTree is JSON object, representing the shell command
	var ParseTree = posix_shell_parser.parse(shell_command);

	// description should be (very) similar to the original 'shell_command' .
	// (There will be differences in white space, and redirections order.)
	var description = DescribeShellCommand(ParseTree);

 */

var ob_utils = require('utils/object_utils');
var str_utils = require('utils/string_utils');
var path_utils = require('utils/path_utils');
var ShellState = require('shell/shell_state');
var ProcessState = require('os/process_state');

module.exports = ShellExecutor ;


function ShellExecutor(shell_process_state, external_programs) {

//TODO:
//Multiple shell-states, for sub-shell emulations?
var shell_state = new ShellState();

var external_program_callback = null;

function set_external_program_callback(callback)
{
	external_program_callback = callback;
}

/* See section "2.9.1 Simple Commands, subsection "Command Search and Execution", item '1.c' */
function isBuiltinUtility(cmd)
{
	var builtin_commands = { "alias" : 1,
				 "bc" : 1,
				 "cd" : 1,
				 "command" : 1,
				 "fc" : 1,
				 "fg" : 1,
				 "getopts" : 1,
				 "jobs" : 1,
				 "kill" : 1,
				 "newgrp" : 1,
				 "pwd" : 1,
				 "read" : 1,
				 "umask" : 1,
				 "unalias" : 1,
				 "Wait" : 1 };

	return (cmd in builtin_commands);
}

/* See section "2.9.1 Simple Commands, subsection "Command Search and Execution", item '1':
returns TRUE if the command DOES NOT have a slash. */
function isNoSlash(cmd)
{
	return (cmd.indexOf("/")==-1);
}


function fork_process_state(process_state,new_assignments)
{
	var new_ps = process_state.clone();
	new_ps.stdin = process_state.stdin;
	new_ps.stdout= process_state.stdout;
	new_ps.stderr= process_state.stderr;

	//Add variable assignments from EXPORTED variables
	var exported_vars = shell_state.get_exported_variables();
	for (var varname in exported_vars ) {
		new_ps.setenv(varname, exported_vars[varname], true);
	}

	//Add new assignments from the command line
	//e.g. "FOO=BAR command"
	for (var varname in new_assignments) {
		new_ps.setenv(varname, new_assignments[varname], true);
	}

	return new_ps;
}

/* run an external command, as if it is found in $PATH */
function runExternalCommand(process_state,new_assignments,tokens)
{
	return exit_code;
}

/* Execute a Command-Tree (as generated by the POSIX-Shell parser */
function ExecCommandTree(obj)
{
	return Command(shell_process_state,obj);
}

/*
Command() - The starting point of Shell-Syntax-Tree parsing.
*/
function Command(process_state, obj)
{
	var type = ob_utils.GetOneKey(obj);
	var value = obj[type];
	switch (type)
	{
	case "SimpleCommand":
		return SimpleCommand(process_state,value);
	case "and_or_list":
		return AndOrList(process_state, value);
	case "list":
		return List(process_state,value);
	case "pipeline":
		return Pipeline(process_state,value);
	case "compound_subshell":
		return CompoundSubshell(process_state,value);
	case "compound_currentshell":
		return CompoundCurrentshell(value);
	default:
		throw "Invalid Command type '" + type + '"';
	}
}

/*
Pipeline() - process commands in a pipeline (e.g. "seq 10 | wc -l").

$ ./parse 'foo|bar|baz'
{
  "pipeline": [
    { "SimpleCommand": { "command": [ { "literal": "foo" } ] } },
    { "SimpleCommand": { "command": [ { "literal": "bar" } ] } },
    { "SimpleCommand": { "command": [ { "literal": "baz" } ] } }
  ]
}

During Execution:
1. Run command
2. Get STDOUT of last command, use it as STDIN for next command
*/
function Pipeline(process_state,obj)
{
	ob_utils.VerifyArray(obj);
	var exit_code = 0 ;

	var orig_stdin = process_state.stdin ;
	var previous_pipe_data = [] ;

	for (var i in obj) {
		var cmd = obj[i];

		//This is terrible... TODO: redo the pipe/stream OS module.
		var new_ps = process_state.clone();
		if (orig_stdin) {
			new_ps.stdin = orig_stdin ;
			orig_stdin = null;
		} else {
			new_ps.stdin.__push_lines(previous_pipe_data);
		}

		exit_code = Command(new_ps,cmd);

		// Manually copy the command's STDOU to the next process
		previous_pipe_data = new_ps.stdout.__get_lines();

		// send STDERR to the parent's process
		process_state.stderr.put_lines(new_ps.stderr.__get_lines());
	}

	// Add the last program's STDOUT to the parent process
	process_state.stdout.put_lines(previous_pipe_data);

	return exit_code ;
}

/*
List() - process commands line a sequential (or background) list
         (e.g. "true ; sleep 60 & false ;")o

$ ./parse 'foo ; bar & baz'
{
  "list": [
    {
      "foreground": {
        "SimpleCommand": { "command": [ { "literal": "foo" } ] }
      }
    },
    {
      "background": {
        "SimpleCommand": { "command": [ { "literal": "bar" } ] }
      }
    },
    {
      "foreground": {
        "SimpleCommand": { "command": [ { "literal": "baz" } ] }
      }
    }
  ]
}

During Execution:
1. Run each command.
2. Commands share STDIN/STDOUT/STDERR (unless redirected for each command).
3. Since it is not likely "background" execution will be emulated here,
   even background commands will be executed sequentially in foreground.
*/
function List(process_state, obj)
{
	var exit_code = 0 ;
	ob_utils.VerifyArray(obj);
	obj.forEach(function(item){
		var exec_type = ob_utils.GetOneKey(item); //type = foreground/background

		//In this emulation, all commands are executed in foreground,
		//the background operator '&' has no effect.
		exit_code  = Command( process_state, item[exec_type] );
	});
	return exit_code;
}


/*
AndOrList() - Process commands in an And/Or list
              (e.g. "true && echo ok || echo fail")

$ ./parse 'true && foo || bar'
{
  "and_or_list": [
    {
      "SimpleCommand": { "command": [ { "literal": "true" } ] }
    },
    "&&",
    {
      "SimpleCommand": { "command": [ { "literal": "foo" } ] }
    },
    "||",
    {
      "SimpleCommand": { "command": [ { "literal": "bar" } ] }
    }
  ]
}

During Execution:
1. Run the first command.
2. The the following commands depending on the previous exitcode
   and the operation (&& or ||)
*/
function AndOrList(process_state, obj)
{
	var exit_code = 0 ;
	ob_utils.VerifyArray(obj);
	var cmd = obj[0];
	exit_code = Command(process_state, cmd);
	var i = 1 ;
	while (i<obj.length) {
		var condition = obj[i];
		var cmd = obj[i+1];
		i += 2;
		if (
			(condition === "&&" && exit_code ===0)
			||
			(condition === "||" && exit_code !==0)
		   ) {
			exit_code = Command(process_state, cmd);
		}
	}
	return exit_code ;

}
/*
SimpleCommand() - Process a single execution command,
                  (e.g. equivalent to a single program to run, a single call to 'exec()')

A Simple Command can contain each of the following:
1. Environment variable assignments
2. Command (i.e. program name, shell alias, shell function) + parameters
3. Redirections

Examples:

## No assignments or redirections here
$ ./parse 'seq 1 2 100'
{
  "SimpleCommand": {
    "command": [
      { "literal": "seq" },
      { "delimiter": null },
      { "literal": "1" },
      { "delimiter": null },
      { "literal": "2" },
      { "delimiter": null },
      { "literal": "100" }
    ]
  }
}

## Assignments and a command
$ ./parse 'CC=clang make'
{
  "SimpleCommand": {
    "command": [
      { "literal": "make" }
    ],
    "assignments": [
      {
        "CC": [ { "literal": "clang" } ]
      }
    ]
  }
}

## command and redirection
$ ./parse 'dmesg -c >/dev/null'
{
  "SimpleCommand": {
    "command": [
      { "literal": "dmesg" },
      { "delimiter": null },
      { "literal": "-c" }
    ],
    "redirections": [
      {
        "filedescriptor": 1,
        "forceclobber": false,
        "filename": [ { "literal": "/dev/null" }
        ],
        "type": "output_file"
      }
    ]
  }
}

Valid Simple-Commands can contain either of the above three - that is,
A Simple-Command with only Environment-Variable-Assignment is valid (it only
changes the shell's variables without executing any program).

See section "2.9.1 Simple Commands" for details, and IMPORTANT notes
about processing order of assignment/redirection/execution.

During Execution:
1. Perform Environment Variable assignment (if any)
2. Prepare redirections (if any)
3. Execute command (if any)
    3.1. "command" will be a list of tokens.
         After evaluation (and paramter expansion and field-splitting),
         the first element is considered the program to execute (or alias,function,etc.)
*/
function SimpleCommand(process_state, obj)
{
	ob_utils.VerifyAllowedKeys(obj, ["command","redirections","assignments"]);

	var exit_code = 0 ;

	//TODO: clone ProcessState, and setup redirection if needed.

	var new_assignments = {};

	if ("assignments" in obj) {
		new_assignments = Assignments( process_state, obj.assignments ) ;
	}

	if (! ("command" in obj) ) {
		// If the current SimpleCommand does not contain an actual command,
		// set any variable assignment to the current shell.
		for (var varname in new_assignments) {
			var value = new_assignments[varname];
			shell_state.variable_set(process_state, varname, value);
		}

		// TODO:
		// 1. handle (empty?) output redirection,
		// 2. return 1 on assignment failure (e.g. re-assignment a readonly variable)
		return 0;
	}

	// Execute the command

	var tokens = Token(process_state, true, obj["command"] );

	// Should not happen, as the parser should detect and prevent it
	if (tokens.length === 0)
		throw "SimpleCommand: internal error, got empty 'command'";

	var command_name = tokens[0];
	if (!isNoSlash(command_name)) {
		//Show error, we don't support running executables with specific path
		//(there are no executables on disk in this emulation)
		throw "Agnostic Emulation error: executables with specific path are not supported (" + command_name + ")";
	}

	// If external program - create new ProcessState.
	// If internal utility - use the current shell's process state.
	var new_process_state = {} ;
	if (isBuiltinUtility(command_name) ||
	    shell_state.isSpecialBuiltinUtility(command_name)) {
		new_process_state = process_state ;
	} else {
		new_process_state = fork_process_state(process_state,new_assignments);
	}

	//TODO: Handle input redirections
	if ("redirections" in obj) {
		//TODO: do pre-exec redirections (reading STDIN) if needed.
		//	redirection_desc = " " + Redirections( obj["redirections"] );
		setup_input_redirections(new_process_state, obj["redirections"]);
	}

	// Execute command
	if (shell_state.isSpecialBuiltinUtility(command_name)) {
		shell_state.runSpecialBuiltinUtility(new_process_state,tokens);
	} else if (isBuiltinUtility(command_name)) {
		runBuiltinUtility(tokens);
	} else {
		if (!external_program_callback)
			throw TypeError("external_program_callback is not initialized");
		exit_code = external_program_callback(new_process_state,command_name,tokens);
	}


	//TODO: Handle output redirections
	if ("redirections" in obj) {
		//TODO:
		//A critical difference between 'POSIX' and 'Agnostic shell:
		//  in POSIX, output redireciton (e.g. creating the files) happens BEFORE
		//  the command is executed. Here, it happens only AFTER.
		setup_output_redirections(new_process_state, obj["redirections"]);
	}

	return exit_code;
}


/*
Assignments() - Process list of envrionment variable assignments.
*/
function Assignments(process_state,obj)
{
	ob_utils.VerifyArray(obj);
	var results = {} ;
	obj.forEach(function(item){
		var varname = ob_utils.GetOneKey(item); //Name of the ENV variable to set.
		var value_token = item[varname]; //Value of the variable
		var value = Token(process_state, false,value_token); //Expand the value, if needed
		results[varname] = value[0];
	});
	return results;
}

/*
Redirections() - Process list of redirections

NOTES:
1. Redirection on the command line can appear BEFORE
the actual command, with variable assignments (though this isn't common in practice).
2. The parser collects redirections (both before and after the command)
into one key 'redirections', though order is maintained.

Examples:
./parse '<input.txt wc -l >output.txt'
{
  "SimpleCommand": {
    "command": [
      { "literal": "wc" },
      { "delimiter": null },
      { "literal": "-l" }
    ],
    "redirections": [
      {
        "filedescriptor": 0,
        "filename": [ { "literal": "input.txt" } ],
        "type": "input_file"
      },
      {
        "filedescriptor": 1,
        "forceclobber": false,
        "filename": [ { "literal": "output.txt" } ],
        "type": "output_file"
      }
    ]
  }
}

*/
function Redirections(obj)
{
	//TODO: generate descriptive string from redirection structure
	ob_utils.VerifyArray(obj);
	return "";
}

/* Iterate over all the redirections, and setup the input ones,
 * into the given 'process_state' */
function setup_input_redirections(process_state,obj)
{
	ob_utils.VerifyArray(obj);
	for (var i in obj) {
		var redir = obj[i];

		// Output redirections - skip them for now
		if (redir.type === "output_file"
			||
		    redir.type === "append_file"
			||
		    redir.type === "output_dup_fd")
			continue;

		// Not supported
		if (redir.type === "input_dup_fd")
			throw "Agnostic Shell Emulation Error: input redirection from a File Descriptor is not yet supported";
		if (redir.type === "inout_file")
			throw "Agnostic Shell Emulation Error: input+output redirection is not yet supported";

		if (redir.type !== "input_file")
			throw "Internal error, unknwon redirection type '" + redir.type + "'";

		// Setup input redirection, from a file
		if (redir.filedescriptor !== 0)
			throw "Agnostic Shell Emulation Error: input redirection to specific file descriptor (other than 0/STDIN) is not yet supported";

		var filename = Token(process_state, false, redir.filename).join("");

		// Read content of 'filename' and put it in STDIN,
		// overriding existing STDIN
		// TODO: do we need to reset 'get stdin callback' ?
		var fl = {} ;
		try {
			filename = path_utils.resolve ( process_state.getcwd(), filename ) ;
			fl = process_state.getFS().openfile(filename,false);
			var content = fl.get_all_lines();
			process_state.stdin.__set_lines(content);
		} catch (e) {
			if (e instanceof process_state.getFS().exception) {
				//TODO: Terminate this shell with exit code
				throw e;
			} else {
				throw e;
			}
		}
	}
}

/* Iterate over all the redirections, and setup the output ones,
 * from the given 'process_state' */
function setup_output_redirections(process_state,obj)
{
	ob_utils.VerifyArray(obj);
	for (var i in obj) {
		var redir = obj[i];

		// Output redirections - skip them for now
		if (redir.type === "input_file"
			||
		    redir.type === "input_dup_fd")
			continue;

		// Not supported
		if (redir.type === "inout_file")
			throw "Agnostic Shell Emulation Error: input+output redirection is not yet supported";

		// Agnostic OS doesn't have (currently) the concent of "File Descriptors".
		// So emulate the common cases of "1>&2" and "2>&1"
		if (redir.type === "output_dup_fd") {
			// Why would anyone redirect "2>&2" ? don't know, but silently ignore it.
			if (redir.filedescriptor === parseInt(redir.filename,10))
				continue;

			if (redir.filedescriptor === 2 && redir.filename == "1") {
				// "2>&1" STDERR to STDOUT
				process_state.stdout.put_lines( process_state.stderr.__get_lines() );
			}
			else if (redir.filedescriptor === 1 && redir.filename == "2") {
				// "1>&2" STDOUT to STDERR
				process_state.stderr.put_lines( process_state.stdout.__get_lines() );
			}
			else
				throw "Agnostic Shell Emulation Error: output file descriptor redirection is limited to STDOUT(1) and STDERR(2)";

			continue;
		}

		// From here one, we expect 'simple' file redirection
		if (redir.type !== "output_file" && redir.type != "append_file")
			throw "Internal error: unknown redirection type '" + redir.type + "'";

		// Agnostic OS doesn't have (currently) the concent of "File Descriptors".
		// So emulate the common cases of "1>FILE" and "2>FILE"
		var content;
		if (redir.filedescriptor===1)
			content = process_state.stdout.__get_lines();
		else if (redir.filedescriptor ===2)
			content = process_state.stderr.__get_lines();
		else
			throw "Agnostic Shell Emulation Error: output redirection is supported only with STDOUT(1) and STDOUT(2) file descriptors";

		var filename = Token(process_state, false, redir.filename).join("");

		//TODO: respect 'noclobber' shell option, and ">|" redirections.
		var fl = {} ;
		try {
			filename = path_utils.resolve ( process_state.getcwd(), filename ) ;
			fl = process_state.getFS().openfile(filename,true);
			if (redir.type === "output_file")
				fl.truncate();
			fl.append(content);
		} catch (e) {
			if (e instanceof process_state.getFS().exception) {
				//TODO: Terminate this shell with exit code
				throw e;
			} else {
				throw e;
			}
		}
	}
}

/*
Token() - Process token(s).

Tokens are very close to WORD in the POSIX Shell document,
with some minor implementation-related differences.
Tokens can contain:
1. unquoted characters ( 'literals' )
2. delimiters (indicating a delimiter in the input string, but see below about
   field-splitting)
3. Double-Quoted strings (with possible parameter-expansion )
4. Subshells (e.g. $() )
5. Backtick-shells
6. Arithmetic expressions
7. Environment variables (e.g. $FOO and ${FOO} )
8. Environment variables with operations (e.g. ${FOO:-BAR} )

This step corresponds to POSIX Shell Secion 2.1 "Shell Introduction" item #4,
and section "2.6 Word Expansions".

NOTES:
1. The number of input elements DOES NOT necessarily corresponds to
number of output elements - see item #2 "field splitting" in Section "2.6 Word Expansions".
For example:
     C="me -s"
     una$C -r
Has one delimiter in the input string (between $C and -r),
but after field-splitting, the command will have three items: 'uname','-s','-r' .
2. Tokens appears as VALUES of many items (e.g. environemt variable assignment,
	redirection's filenames).

EXAMPLE:
(note that the "command" key points to an array, which is the Token):
$ ./parse 'H"EL"LO${FOO-WO}$(echo rld)$((5*$(id -u)))'
{
  "SimpleCommand": {
    "command": [
      { "literal": "H" },
      { "doublequotedstring": [ { "literal": "EL" } ] },
      { "literal": "LO" },
      { "envvar_operation": {
          "value": [ { "literal": "WO" } ],
          "operation": "-",
          "envvar": "FOO"
        }
      },
      {
        "subshell": {
          "SimpleCommand": {
            "command": [
              { "literal": "echo" },
              { "delimiter": null },
              { "literal": "rld" }
            ]
          }
        }
      },
      {
        "arithmetic": {
          "arithmetics_op_list": [
            { "literal": 5 },
            "*",
            {
              "subshell": {
                "SimpleCommand": {
                  "command": [
                    { "literal": "id" },
                    { "delimiter": null },
                    { "literal": "-u" }
                  ]
                }
              }
            }
          ]
        }
      }
    ]
  }
}


During Execution:
1.  This module only describes tokens, so there's no need to execute commands
    (e.g. "id -u", or arithmetics calculations in the above example).
*/
function Token(process_state,allow_multiple_fields,obj)
{
	var results = [] ;
	if (! (process_state instanceof ProcessState) )
		new TypeError("proces_state param is not a ProcessState object");
	ob_utils.VerifyBoolean(allow_multiple_fields);
	ob_utils.VerifyArray(obj);
	obj.forEach(function(item){
		var token_type = ob_utils.GetOneKey(item);
		var token_value = item[token_type];
		var desc = "" ;
		switch(token_type)
		{
		case "literal":
			desc = token_value;
			break;

		case "delimiter":
			desc = " ";
			break;

		case "singlequotedstring":
			desc = SingleQuotedString(process_state, token_value);
			break;

		case "doublequotedstring":
			desc = DoubleQuotedString(process_state, token_value);
			break;

		case 'envvar_operation':
			desc = EnvVarOperation(token_value);
			break;

		case 'envvar':
			desc = EnvVar(process_state, token_value);
			break;

		case 'arithmetic':
			desc = Arithmetic(process_state,token_value);
			break;

		case 'subshell':
			//TODO: Take STDOUT of the program, and use it as token
			desc = Subshell(process_state, token_value);
			break;

		case 'backtickshell':
			//TODO: Take STDOUT of the program, and use it as token
			desc = BacktickShell(token_value);
			break;

		default:
			throw "Unknown Posix-Shell-Token '" + token_type + '"';
		}
		results.push(desc);
	});

	/* Join all sub-tokens */
	var str = results.join("");

	/* field splitting */
	var fields = [] ;
	if (allow_multiple_fields)
		fields = str_utils.splitShellquotes(str);
	else
		fields.push(str); //just one field, regardless of delimiters

	/* TODO: tilda/Filename expansion, if allowed */

	/*  quotes removal */
	for (var i in fields) {
		fields[i] = str_utils.removeShellquotes(fields[i]);
	}

	return fields;
}




/*
EnvVar() - Process an environment variable, based on its name.

Example:
$ ./parse '$USER'
{
  "SimpleCommand": {
    "command": [
      {
        "envvar": "USER"
      }
    ]
  }
}

During Execution:
1. Return the content of the variable, based on the current shell execution environment
*/
function EnvVar(process_state,obj)
{
	return shell_state.variable_get(process_state,obj);
}

/*
EnvVarOperation() - Process an environment variable with an operation
                    (e.g. "${FOO:=BAR}" or "${FOO%test$(id -u)}"

An environment variable operation is represented by the following structure:
1. "envvar"    - the name of the variable. never expanded.
2. "operation" - as described in section "2.6.2 Parameter expansion"
3. "value"     - a token to assign. Could be a compounded Token, needs to
	         be recursively evalutated.

NOTE:
1. "value" might be missing, if the input syntax was "${FOO=}".

Example:
$ ./parse '${FOO:-$(uname)}'
{
  "SimpleCommand": {
    "command": [
      {
        "envvar_operation": {
          "value": [
            {
              "subshell": {
                "SimpleCommand": {
                  "command": [ { "literal": "uname" } ]
                }
              }
            }
          ],
          "operation": ":-",
          "envvar": "FOO"
        }
      }
    ]
  }
}

During Execution:
1. Return the content of the variable, based on the current shell execution environment
*/
function EnvVarOperation(obj)
{
	ob_utils.VerifyAllowedKeys(obj, ["envvar","operation","value"]);

	var varname = obj["envvar"];
	//TODO: when exeuting/emulating, get the content (if any)
	//	of "varname".

	var operation = obj["operation"];

	//TODO: when executing/emulating, calculate the content of
	//	the value.
	var value = "";
	/* "value" is optional - e.g. no "value" in  ${FOO=} */
	if (obj["value"]) {
		value = Token(true,obj["value"]);
	}

	//TODO: when executing/emulating, set the returned value
	//	based on the varname+operation+value.

	return '${' + varname + operation + value + '}';
}

/*
SingleQuotedString() - just like a literal value.

Single Quoted Strings are just like literals */
function SingleQuotedString(process_state, obj)
{
	return "'" + obj + "'" ;
}

/*
DoubleQuotedString() - Evalutate tokens inside a double-quoted string.
In this implementation, a Double-Quoted String is similar to any other
compound token.
See section "2.2.3 Double-Quotes".

TODO
1. and the special handling of "@".

EXAMPLE:
$ ./parse 'echo "foo$((1+4))$baz"'
{
  "SimpleCommand": {
    "command": [
      { "literal": "echo" },
      { "delimiter": null },
      {
        "doublequotedstring": [
          { "literal": "foo" },
          { "arithmetic": {
              "arithmetics_op_list": [
                { "literal": 1 },
                "+",
                { "literal": 4 }
              ]
            }
          },
          { "envvar": "baz" }
        ]
      }
    ]
  }
}

*/
function DoubleQuotedString(process_state, obj)
{
	var desc = Token(process_state, false,obj);
	return '"' + desc + '"' ;
}


/*
Subshell() - Process a subshell execution.
The command to execute can be a full-fledged shell syntax command.

Example:
$ ./parse 'echo $(uname)'
{
  "SimpleCommand": {
    "command": [
      { "literal": "echo" },
      { "delimiter": null },
      {
        "subshell": {
          "SimpleCommand": { "command": [ { "literal": "uname" } ] }
        }
      }
    ]
  }
}

During Execution:
1. During Executing/Emulation, a new Shell Execution Environment needs to be established.
2. The STDIN of the existing shell should be passed to the subshell.
3. The STDOUT of this process should be returned as a token.
*/
function Subshell(process_state, obj)
{
	/* NOTE: This can happen with an empty subshell, e.g.: "echo $()" */
	if (obj === null)
		return "";

	var new_ps = process_state.clone();
	new_ps.stdin = process_state.stdin ;

	var exit_code  = Command(new_ps,obj);

	//TODO: what about the exit code? check the spec...

	// STDERR goes to the shell's STDERR
	process_state.stderr.put_lines( new_ps.stderr.__get_lines() ) ;

	// STDOUT is returns as a string,
	// will be used as a token.
	// NOTE: it doesn't matter how many lines are returned -
	// the are concatenated here, and will be splitted
	// into correct fields in "SimpleCommand()" .
	var output = new_ps.stdout.__get_lines().join(" ");

	return output;
}

/*
BacktickShell() - Process a backtick subshell

Example:
$ ./parse 'echo `uname`'
{
  "SimpleCommand": {
    "command": [
      { "literal": "echo" },
      { "delimiter": null },
      {
        "backtickshell": {
          "SimpleCommand": { "command": [ { "literal": "uname" } ] }
        }
      }
    ]
  }
}


During Execution:
1. During Executing/Emulation, a new Shell Execution Environment needs to be established.
2. The STDIN of the existing shell should be passed to the subshell.
3. The STDOUT of this process should be returned as a token.

TODO:
Backtick-shells have some pecularities. Review the standard.
*/
function BacktickShell(obj)
{
	/* NOTE: This can happen with an empty subshell, e.g.: "echo ``" */
	if (obj === null)
		return "";

	var new_ps = process_state.clone();
	new_ps.stdin = process_state.stdin ;

	var exit_code  = Command(new_ps,obj);

	//TODO: what about the exit code? check the spec...

	// STDERR goes to the shell's STDERR
	process_state.stderr.put_lines( new_ps.stderr.__get_lines() ) ;

	// STDOUT is returns as a string,
	// will be used as a token.
	// NOTE: it doesn't matter how many lines are returned -
	// the are concatenated here, and will be splitted
	// into correct fields in "SimpleCommand()" .
	var output = new_ps.stdout.__get_lines().join(" ");

	return output;
}

/*
CompoundSubshell() - Process a compound list of commands in a subshell.
                     (e.g.   "seq 10 | ( sed -u 1q ; sort -nr)" ).

NOTES:
See "2.9.4 Compound Commands" (http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_09_04),

During Execution:
1. The commands should get STDIN from current shell,
2. The commands should return STDOUT,STDERR to current shell
   (to be printed to console, or sent to next piped program)
*/
function CompoundSubshell(process_state,obj)
{
	var new_ps = process_state.clone();
	new_ps.stdin = process_state.stdin;

	var exit_code = Command(new_ps, obj);
	//
	// send STDERR to the parent's process
	process_state.stderr.put_lines(new_ps.stderr.__get_lines());

	// Add the last program's STDOUT to the parent process
	process_state.stdout.put_lines(new_ps.stdout.__get_lines());

	return exit_code ;
}

/*
CompoundCurrentsshell() - Process a compound list of commands in current shell.
                     (e.g.   "false && { echo failed >&2 ; exit 1 ; }

NOTES:
See "2.9.4 Compound Commands" (http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_09_04),

During Execution:
1. The commands should get STDIN from current shell,
2. The commands should return STDOUT,STDERR to current shell
   (to be printed to console, or sent to next piped program)
*/
function CompoundCurrentshell(obj)
{
	return "{" + Command(obj) + " ; }";
}


/*
Arithmetic() - Process arithmetic parameter expansions (e.g. "$((5+4))" ).

NOTE:
1. Arithmetic Expressions can contain recursive parameter expansions (e.g
   environment variables, subshells, etc.).

Example:
$ ./parse '$((1+2*$(id -u)+42))'
{
  "SimpleCommand": {
    "command": [
      {
        "arithmetic": {
          "arithmetics_op_list": [
            { "literal": 1 },
            "+",
            {
              "arithmetics_op_list": [
                { "literal": 2 },
                "*",
                {
                  "subshell": {
                    "SimpleCommand": {
                      "command": [
                        { "literal": "id" },
                        { "delimiter": null },
                        { "literal": "-u" }
                      ]
                    }
                  }
                }
              ]
            },
            "+",
            { "literal": 42 }
          ]
        }
      }
    ]
  }
}

During Execution:
Return the integer value of the operation.

TODO:
1. implement all required arithmetic operations
*/
function Arithmetic(process_state,obj)
{
	return ArithmeticExpression(process_state, obj);
}

/*
ArithmeticExpression() - Process the possible tokens in an arithmetic expression.

*/
function ArithmeticExpression(process_state, obj)
{
	var op = ob_utils.GetOneKey(obj);
	var value = obj[op];
	var result;
	switch (op)
	{
	case 'literal':
		result = value;
		break;

	case 'envvar':
		result = EnvVar(process_state, value);
		break;

	case 'arithmetics_op_list':
		result = ArithmeticOpList(process_state,value);
		break;

	case 'arithmetic':
		result = ArithmeticExpression(process_state, value);
		break;

	case 'subshell':
		result = Subshell(process_state,value);
		break;

	default:
		throw "Uknown arithmetic operation '" + op + '"';
	}

	// Empty strings are taken as zero (e.g. a non-existing ENV var).
	if (result === "")
		result = "0" ;

	if (!ob_utils.IsStrictDecimalIntegerValue(result)) {
		//TODO: return error + message to STDERR
		result = 0 ;
	}

	result = parseInt(result,10); //convert it to a javascript integer.
	return result;
}


/* Process an list of arithmetics operation, with the same precedence
   (eg. a list of addition/substractions, or a list of multiplications/divisions).
   During execution/emulation, 'value' should contain the accumulated value */
function ArithmeticOpList(process_state, obj)
{
	ob_utils.VerifyArray(obj);
	var operand = obj[0];
	var value = ArithmeticExpression(process_state, operand);
	var i = 1 ;
	while (i<obj.length) {
		var operator = obj[i];
		var operand2 = obj[i+1];
		i += 2;
		var value2 = ArithmeticExpression(process_state, operand2);

		switch (operator)
		{
		case '+':
			value += value2 ;
			break;

		case '-':
			value -= value2;
			break;

		case '*':
			value *= value2;
			break;

		case '/':
			value = Math.floor(value / value2);
			break;

		default:
			throw "Invalid arithmetic operator: " + operator ;
		}

	}
	return value;
}

	return {
		"ExecuteCommand" : ExecCommandTree,
		__shell_state : shell_state, //expose is for debugging only.
		set_external_program_callback: set_external_program_callback,
		};
};
