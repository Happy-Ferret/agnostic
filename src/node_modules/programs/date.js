/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/

/*
A Naive implementation of date(1)
*/
"use strict";

var sprintf = require('utils/sprintf');
var ob_utils = require('utils/object_utils');
var strftime = require('utils/strftime');
var PosixGetOpt = require('utils/posix-getopt');
var ProgramBase = require('programs/program_base');

/* For now, all times are UTC under Agnostic */
var strftimeUTC = strftime.strftimeUTC;

module.exports = ProgramDate;

function ProgramDate() {
	this.name = "ProgramDate";
	this.program_name = "date";
	// Default output format
	this.output_format = "%a %b %d %H:%M:%S %Z %Y";
	this.display_time = null; // use this instead of 'now'
}

ProgramDate.prototype = new ProgramBase();
ProgramDate.prototype.constructor = ProgramDate;

ProgramDate.prototype.parse_command_line=function() {
	// TODO: The "-I" option is incorrectly implemented:
	// The argument is optional in GNU Date, but mandatory here.
	var parser = new PosixGetOpt(':' +
				     'd:(date)' +
			             'f:(file)' +
				     'I:(iso-8601)' +
				     'R(rfc-2822)' +
				     '\u1002:(rfc-3339)' +
				     '\u1000(help)' +
				     '\u1001(version)',
				     this.argv);

	var option;
	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
			case 'd':
				this.parse_time_string(option.optarg);
				break;

			case 'f':
				this.error_not_implemented_feature('-f','not implemented');
				break;

			/* iso-8601 format, with optional precision */
			case 'I':
				switch (option.optarg)
				{
				case '':
				case 'date':
					this.output_format = "%Y-%m-%d";
					break;
				case 'hour':
					this.output_format = "%Y-%m-%dT%H+%z";
					break;
				case 'minute':
					this.output_format = "%Y-%m-%dT%H:%M%z";
					break;
				case 'second':
					this.output_format = "%Y-%m-%dT%H:%M%S%z";
					break;
				case 'ns':
					this.output_format = "%Y-%m-%dT%H:%M%S,%N%z";
					break;
				default:
					this.error_invalid_argument('invalid precision "' + option.optarg + '"');
					break;
				}
				break;

			/* -R/--rfc2822 */
			case 'R':
				this.output_format = "%a, %d %b %Y %H:%M:%S %z";
				break;

			/* --rfc-3339 with precision */
			case '\u1002':
				switch (option.optarg)
				{
				case 'date':
					this.output_format = "%Y-%m-%d";
					break;
				case 'seconds':
					this.output_format = "%Y-%m-%d %H:%M:%S%z";
					break;
				case 'ns':
					this.output_format = "%Y-%m-%d %H:%M:%S.%N%z";
					break;
				default:
					this.error_invalid_argument('invalid precision "' + option.optarg + '"');
					break;
				}
				break;

			case '\u1000':
				this.show_help();
				this.exit(0);

			case '\u1001':
				this.show_version();
				this.exit(0);

			/* this is Posix-Getopt's way of indicating
			   that an optional argument to 'I' was not given. */
			case '?':
				if (option.optopt=='I')
				{
					this.output_format = "%Y-%m-%d";
					break;
				}

			default:
				this.error_invalid_argument(option.errmsg);
		}
	}

	//Check non-option arguments,
	//for custom date format
	var args = this.argv.slice(parser.optind());
	if (args.length>1) {
		this.error_invalid_argument("extra operand: '" + args[1] + '"');
	}
	if (args.length==1) {
		var s = args[0];
		// Custom date format
		if (s.length>0 && s[0]==="+") {
			this.output_format = s.substr(1);
		}
		else {
		   //assume the user is trying to set the date
		   this.error_not_implemented_feature('set date','not implemented');
		}
	}
}

/* Parsing date/time strings is a world of pain.
   'date' in GNU Coreutils has an entire YACC parser code
   to handle (most of) the possible date strings.
   Currently no parsring is implemented.
   TODO:
   support unambigious input (with a simple regex?)
   support @NNNNNN for seconds-since-epoch format - enabling date arithmatics.
   */
ProgramDate.prototype.parse_time_string=function(time_str) {
	if (time_str.length===0)
		this.error_invalid_argument("invalid time specified for -d option");

	// Seconds since epoch - parse it
	if (time_str[0] === "@") {
		var seconds = time_str.substr(1);
		if (!ob_utils.IsStrictDecimalIntegerValue(seconds))
			this.error_invalid_argument("invalid number of seconds '" + seconds + "'");
		this.display_time = parseInt(seconds);
		return;
	}

	// %Y-%m-%h - parse it
	var ymd_re = /^(\d{4})-(\d{2})-(\d{2})$/;
	var ymd_match = ymd_re.exec(time_str);
	if (ymd_match) {
		var dt = new Date(ymd_match[1],ymd_match[2]-1,ymd_match[3],12,0,0);
		var n = dt.getTime() ;
		this.display_time = Math.floor(n / 1000) - dt.getTimezoneOffset()*60; //Javascript returns number of MILLI-SECONDS.
		return ;
	}

	// %Y-%m-%h %H:%M - parse it
	var ymdhm_re = /^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2})$/;
	var ymdhm_match = ymdhm_re.exec(time_str);
	if (ymdhm_match) {
		var dt = new Date(ymdhm_match[1],ymdhm_match[2]-1,ymdhm_match[3],ymdhm_match[4],ymdhm_match[5],0);
		var n = dt.getTime() ;
		this.display_time = Math.floor(n / 1000) - dt.getTimezoneOffset()*60; //Javascript returns number of MILLI-SECONDS.
		return ;
	}

	// %Y-%m-%h %H:%M:%S - parse it
	var ymdhms_re = /^(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})$/;
	var ymdhms_match = ymdhms_re.exec(time_str);
	if (ymdhms_match) {
		var dt = new Date(ymdhms_match[1],ymdhms_match[2]-1,ymdhms_match[3],ymdhms_match[4],ymdhms_match[5],ymdhms_match[6]);
		var n = dt.getTime() ;
		this.display_time = Math.floor(n / 1000) - dt.getTimezoneOffset()*60; //Javascript returns number of MILLI-SECONDS.
		return ;
	}

	this.error_invalid_argument("-d option accepts the following formats: @NNNNNNNN, 'YYYY-mm-dd', 'YYYY-mm-dd HH:MM', 'YYYY-mm-dd HH:MM:SS'");
}

/*
Partial Implementation of 'date'
*/
ProgramDate.prototype.internal_run=function() {

	this.parse_command_line();

	//No parameters - just print the date
	var tm = (this.display_time)
		?this.display_time
		:this.runtime.getOS().time(); // get global system time
	var dt = new Date(tm*1000); // time is in seconds, convert to Javascript's milliseconds

	var text = strftimeUTC(this.output_format, dt);
	this.runtime.stdout.put_line(text);

	return 0;
}

