/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/

/*
A Naive implementation of cut(1)
*/
"use strict";

var ob_utils = require('utils/object_utils');
var sprintf = require('utils/sprintf');
var PosixGetOpt = require('utils/posix-getopt');
var ProgramBase = require('programs/program_base');
var Filesystem = require('os/filesystem');

module.exports = ProgramCut;

function ProgramCut() {
	this.name = "ProgramCut";
	this.program_name = "cut";
	this.files = [] ; //input file names
	this.fields = null;
	this.characters= null;
	this.bytes = null;
	this.positions = { } ;
	this.min_position_and_above = null;
	this.max_position_and_below = null;
	this.complement = false;
	this.only_delimited = false;
	this.input_separator = null;
	this.output_separator = null;
}
ProgramCut.prototype = new ProgramBase();
ProgramCut.prototype.constructor = ProgramCut;

ProgramCut.prototype.parse_command_line=function() {
	var parser = new PosixGetOpt('b:(bytes)f:(fields)c:(characters)d:(delimiter)n\u1005(complement)s(only-delimiter)\u1006:(output-delimiter)\u1000(help)\u1001(version)', this.argv);

	var option;
	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
			case 'b':
				if (this.fields || this.bytes || this.characters)
					 this.error_invalid_argument("only one type of list may be specified");
				this.bytes = true;
				this.parse_position_list(option.optarg);
				break;

			case 'f':
				if (this.fields || this.bytes || this.characters)
					 this.error_invalid_argument("only one type of list may be specified");
				this.fields = true;
				this.parse_position_list(option.optarg);
				break;

			case 'c':
				if (this.fields || this.bytes || this.characters)
					 this.error_invalid_argument("only one type of list may be specified");
				this.characters = true;
				this.parse_position_list(option.optarg);
				break;

			case 'n': //ignored
				break;

			case 'd':
				this.input_separator = option.optarg;
				break;

			case 's':
				this.only_delimited = true;
				break;

			case '\u1006': //output-delimiter
				this.output_separator = option.optarg;
				break;

			case '\u1005': //complement
				this.complement = true;
				break;


			case '\u1000':
				this.show_help();
				break;

			case '\u1001':
				this.show_version();
				break;

			default:
				this.error_invalid_argument(option.errmsg);
		}
	}
	if (!this.fields && !this.bytes && !this.characters)
		this.error_invalid_argument("you must specify a list of bytes, characters, or fields");

	if (this.only_delimited && !this.fields)
		this.error_invalid_argument("suppressing non-delimited lines makes sense only when operating on fields");

	if (this.input_separator && !this.fields)
		this.error_invalid_argument("an input delimiter may be specified only when operating on fields");

	// Default input field separator, based on which cut we're doing
	if (this.input_separator === null) {
		if (this.fields)
			this.input_separator = "\t";
		else
			// In this implementation - no difference between characters and bytes
			this.input_separator = "" ;
	}
	// default output field - same as input separator
	if (this.output_separator === null)
		this.output_separator = this.input_separator;

	if (this.input_separator.indexOf("\n") != -1 ||
	    this.output_separator.indexOf("\n") != -1)
		this.error_not_implemented_feature("New-Line separator","this vesion of 'cut' does not support new-line as field separator");

	// Get first/increment/last parameters
	var args = this.argv.slice(parser.optind());
	// If no files are given, process "stdin"
	if (args.length === 0)
		args.push("-");
	this.files = args ;
}


ProgramCut.prototype.parse_position_list=function(list) {
	var items = list.split(",");
	for (var i in items) {
		var t = items[i];

/* These are the four types of position specifiers
   three from:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/cut.html
   plus one from GNU coreutils:
     N		field N
     N-		field N and up
     -M		field 1 to M
     N-M	fields N to M
*/
		var m;
		if (m = t.match(/^(\d+)$/)) {
			// Exactly one field
			this.positions[parseInt(m[1])] = 1;
		} else if (m = t.match(/^(\d+)-$/)) {
			// field N and up
			var v = parseInt(m[1]);
			if (( this.min_position_and_above === null) ||
			     v < this.min_position_and_above)
				this.min_position_and_above = v;
		} else if (m = t.match(/^-(\d+)$/)) {
			// field N and below
			var v = parseInt(m[1]);
			if ((this.max_position_and_below === null) ||
			     v > this.max_position_and_below)
				this.max_position_and_below = v;
		} else if (m = t.match(/^(\d+)-(\d+)$/)) {
			// field N and below
			var min = parseInt(m[1]);
			var max = parseInt(m[2]);
			if (min>max)
				this.error_invalid_argument("invalid decreasing range");
			for (var j=min;j<=max;j++)
				this.positions[j] = 1;
		} else {
			this.error_invalid_argument("invalid byte, character or field list");
		}
	}

	/* if there's an overlap between min/max positions, just enable all positions */
	if (this.max_position_and_below !== null &&
	    this.min_position_and_above !== null &&
	    (this.max_position_and_below >= this.min_position_and_above)) {
		this.min_position_and_above = 1;
		this.max_position_and_below = null ;
		this.positions = {};
	}
}

ProgramCut.prototype.cut_content=function(content) {
	for (var i in content) {
		var line = content[i];
		var items = [];
		items = line.split(this.input_separator);

		if (items.length===1) {
			// no delimiters in this line - print original line (fi needed)
			if (!this.only_delimited)
				this.runtime.stdout.put_line(line);
			continue;
		}

		var output_items = [] ;
		for (var j in items) {
			var pos = parseInt(j)+1;
			var match = ( (pos in this.positions)
					||
				      ((this.max_position_and_below !== null)
				        && (pos<=this.max_position_and_below))
					||
				      ((this.min_position_and_above !== null)
				        && (pos>=this.min_position_and_above))
					);
			if (this.complement)
				match = !match;

			if (match)
				output_items.push( items[j] );
		}

		var output_line = output_items.join(this.output_separator);

		this.runtime.stdout.put_line(output_line);
	}
}

ProgramCut.prototype.cut_stdin=function() {
	var content = this.runtime.stdin.get_all_lines();
	this.cut_content(content);
}

ProgramCut.prototype.cut_file=function(filename) {
	var fl = {} ;
	try {
		fl = this.runtime.getFS().openfile(filename,false);
	} catch (e) {
		if (e instanceof this.runtime.getFS().exception) {
			this.exit_error(e.toString());
		} else {
			throw e;
		}
	}
	var content = fl.get_all_lines();
	this.cut_content(content);
}

ProgramCut.prototype.internal_run=function() {
	this.parse_command_line();

	for( var i in this.files ) {
		var filename = this.files[i];
		if (filename === "-")
			this.cut_stdin();
		else
			this.cut_file(filename);
	}

	return 0;
}
