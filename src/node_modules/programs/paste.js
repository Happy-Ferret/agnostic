/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/

/*
A Naive implementation of Paste(1)
*/
"use strict";

var ob_utils = require('utils/object_utils');
var path_utils = require('utils/path_utils');
var sprintf = require('utils/sprintf');
var PosixGetOpt = require('utils/posix-getopt');
var ProgramBase = require('programs/program_base');
var Filesystem = require('os/filesystem');

module.exports = ProgramPaste;

function ProgramPaste() {
	this.name = "ProgramPaste";
	this.program_name = "paste";
	this.files = [] ; //input file names
	this.delimiters = [] ;
	this.serial = false;
}
ProgramPaste.prototype = new ProgramBase();
ProgramPaste.prototype.constructor = ProgramPaste;

ProgramPaste.prototype.parse_command_line=function() {
	var parser = new PosixGetOpt('d:(delimiters)' +
				     's(serial)' +
				     '\u1000(help)' +
				     '\u1001(version)', this.argv);

	var option;
	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
			case 'd':
				this.delimiters = option.optarg.split('');
				break;

			case 's':
				this.serial = true;
				break;

			case '\u1000':
				this.show_help();
				this.exit(0);

			case '\u1001':
				this.show_version();
				this.exit(0);

			default:
				this.error_invalid_argument(option.errmsg);
		}
	}


	// Default delimiter is tab
	if (this.delimiters.length===0)
		this.delimiters = [ "\t" ];

	// Get first/increment/last parameters
	var args = this.argv.slice(parser.optind());
	// If no files are given, process "stdin"
	if (args.length === 0)
		args.push("-");
	this.files = args ;
}


ProgramPaste.prototype.paste_serial_content=function(filename,content) {
	var output_line = "" ;
	var delimiter_index = 0 ;
	var delimiter_max = this.delimiters.length-1 ;
	for (var i in content) {
		if (output_line.length > 0) {
			output_line += this.delimiters[delimiter_index++];
			if (delimiter_index>delimiter_max)
				delimiter_index=0;
		}
		output_line += content[i];
	}
	this.runtime.stdout.put_line(output_line);
}

ProgramPaste.prototype.paste_parallel_content=function(filename,content)
{
	var stdin_content = [] ;
	var stdin_read = false;
	var files_content = [] ;
	var input_count = 0 ; //number of inputs we have

	for (var idx in this.files) {
		var filename = this.files[idx];

		if (filename === "-") {
			if (! stdin_read) {
				stdin_read = true;

				stdin_content = this.runtime.stdin.get_all_lines();
				if (stdin_content.length>0)
					input_count++;
			}
		} else {
			var fl = {} ;
			try {
				filename = path_utils.resolve ( this.runtime.getcwd(), filename ) ;
				fl = this.runtime.getFS().openfile(filename,false);
				files_content[idx] = fl.get_all_lines();
				if (files_content[idx].length>0)
					input_count++;
			} catch (e) {
				if (e instanceof this.runtime.getFS().exception) {
					this.exit_error(e.toString());
				} else {
					throw e;
				}
			}
		}
	}

	var delimiter_max = this.delimiters.length-1 ;
	while (input_count>0) {
		var first_field = true;
		var delimiter_index = 0 ;
		var output_line = "" ;

		for (var idx in this.files) {
			var field_content = "" ;
			var content_stream;
			var filename = this.files[idx];

			if (filename === "-")
				content_stream = stdin_content;
			else
				content_stream = files_content[idx];

			if (content_stream.length>0) {
				field_content = content_stream.shift();
				if (content_stream.length===0)
					input_count--;
			}


			if (!first_field) {
				output_line += this.delimiters[delimiter_index++];
				if (delimiter_index>delimiter_max)
					delimiter_index=0;
			}
			first_field = false;

			output_line += field_content;
		}
		this.runtime.stdout.put_line(output_line);
	}
}

ProgramPaste.prototype.internal_run=function() {
	this.parse_command_line();

	if (this.serial) {
		this.process_files (this.files, this.paste_serial_content );
	} else {
		this.paste_parallel_content();
	}

	return 0;
}
