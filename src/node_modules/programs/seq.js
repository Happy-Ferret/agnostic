/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/

/*
A Naive implementation of seq(1)
*/
"use strict";

var sprintf = require('utils/sprintf');
var ob_utils = require('utils/object_utils');
var PosixGetOpt = require('utils/posix-getopt');
var ProgramBase = require('programs/program_base');

module.exports = ProgramSeq;

function ProgramSeq() {
	this.name = "ProgramSeq";
	this.program_name = "seq";
	this.first = 1 ;
	this.last = null ;
	this.increment = 1 ;
	this.format = "%f";
	this.separator = "\n";
	this.equal_width = false ;
}
ProgramSeq.prototype = new ProgramBase();
ProgramSeq.prototype.constructor = ProgramSeq;

ProgramSeq.prototype.parse_command_line=function() {
	var parser = new PosixGetOpt(':f:(format)s:(separator)w(equal-width)\u1000(help)\u1001(version)', this.argv);

	var option;
	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
			case 'f':
				//TODO: verify this is a valid printf format
				this.format = option.optarg;
				break;

			case 's':
				this.separator = option.optarg;
				break;

			case 'w':
				this.equal_width = true ;
				break;

			case '\u1000':
				this.show_help();
				this.exit(0);

			case '\u1001':
				this.show_version();
				this.exit(0);

			default:
				this.error_invalid_argument(option.errmsg);
		}
	}

	// Get first/increment/last parameters
	var extra_params = this.argv.length - parser.optind();
	switch(extra_params)
	{
	case 0:
		this.error_invalid_argument("missing operand"); //never erturns
	case 1:
		this.last = this.argv[parser.optind()];
		break;
	case 2:
		this.first = this.argv[parser.optind()];
		this.last = this.argv[parser.optind()+1];
		break;
	case 3:
		this.first = this.argv[parser.optind()];
		this.increment = this.argv[parser.optind()+1];
		this.last = this.argv[parser.optind()+2];
		break;
	default:
		this.error_invalid_argument("extra operand: '" + this.argv[parser.optind()+3] + "'");
		//never returns
	}

	// Validate parameters
	var tmp = [ this.first, this.increment, this.last ];
	for (var i in tmp) {
		var value = tmp[i];
		if (!ob_utils.IsStrictFloatValue(value))
			this.error_invalid_argument("invalid floating point argument: " + tmp[i] );
	}
	this.first = parseFloat(this.first);
	this.increment = parseFloat(this.increment);
	this.last = parseFloat(this.last);

	if (this.equal_width && (this.format !== "%f"))
		this.error_invalid_argument(" format string may not be specified when printing equal width strings");

	if (this.equal_width) {
		var max = Math.max(this.first,this.last);
		var digits = Math.round(Math.log(max)/Math.log(10))+1;
		this.format = "%0" + digits + "f";
	}
}

ProgramSeq.prototype.internal_run=function() {
	this.parse_command_line();

	if (this.separator === "\n") {
		for (var i = this.first ;
			((this.increment>=0) && (i<= this.last)) ||
			((this.increment<0) && (i>=this.last)) ;
			i = i + this.increment ) {
			var value = sprintf.sprintf(this.format, i);
			this.runtime.stdout.put_line(value);
		}
	} else {
		var result = [] ;
		for (var i = this.first ;
			((this.increment>=0) && (i<= this.last)) ||
			((this.increment<0) && (i>=this.last)) ;
			i = i + this.increment ) {
			var value = sprintf.sprintf(this.format, i);
			result.push(value);
		}
		this.runtime.stdout.put_line(result.join(this.separator));
	}

	return 0;
}

