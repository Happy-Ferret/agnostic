/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/

/*
A Naive implementation of tail(1)
*/


var sprintf = require('utils/sprintf');
var PosixGetOpt = require('utils/posix-getopt');
var ProgramBase = require('programs/program_base');
var Filesystem = require('os/filesystem');

function ProgramTail() {
	this.name = "ProgramTail";
	this.program_name = "tail";
	this.verbose = false;
	this.quiet = false;
	this.lines = "10" ; //note: must start as a string
	this.files = [] ; //input file names
}
ProgramTail.prototype = new ProgramBase.ProgramBase();
ProgramTail.prototype.constructor = ProgramTail;

ProgramTail.prototype.parse_command_line=function() {
	var parser = new PosixGetOpt.BasicParser(':1234567890c:(bytes)n:(lines)q(quiet)v(verbose)\u1002(silent)\u1000(help)\u1001(version)f:(follow)F\u1003:(pid)\u1004(retry)s:(sleep-interval)\u1005:(max-unchanged-stats)', this.argv);

	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
				//Discouraged but still supported usage,
				//e.g.  Tail -4 FILE
				this.lines = parseInt(option.option,10);
				break;

			case 'c':
				this.error_not_implemented_feature("-c/--bytes", "tail with bytes is not implemented");
				break;

			case 'n':
				this.lines = option.optarg;
				break;

			case 'q':
				this.quiet = true ;
				break;

			case 'v':
				this.verbose = true ;
				break;

			case '\u1002':
				this.quiet = true ;
				break;

			case '\u1000':
				this.show_help();
				break;

			case '\u1001':
				this.show_version();
				break;

			case 'f':
				this.error_not_implemented_feature("-f/--follow", "tail -f  is not implemented");
			case 'F':
				this.error_not_implemented_feature("-F", "tail -F  is not implemented");
			case '\u1003': //--pid
				this.error_not_implemented_feature("--pid", "tail --pid  is not implemented");

			case 's':
				this.error_not_implemented_feature("-s/--sleep-interval", "tail --sleep-interval  is not implemented");

			case '\u1004': // retry
				this.error_not_implemented_feature("--retry", "tail --retry is not implemented");

			case '\u1005': // max-unchanged-stats
				this.error_not_implemented_feature("--max-unchanged-stats", "tail --max-unchanged-stats is not implemented");

			default:
				this.error_invalid_argument(option.errmsg);
		}
	}

	// Get first/increment/last parameters
	var args = this.argv.slice(parser.optind());
	// If no files are given, process "stdin"
	if (args.length === 0)
		args.push("-");
	this.files = args ;

	// Default for multiple files is showing file names,
	// unless quiet/verbose is explicitly specified
	if ( (args.length>1) && !this.quiet && !this.verbose )
		this.verbose = true;


	var multiplier = 1 ;
	if (/b$/.test(this.lines)) multiplier = 512;
	if (/kB$/.test(this.lines)) multiplier = 1000;
	if (/K$/.test(this.lines)) multiplier = 1024;
	if (/MB$/.test(this.lines)) multiplier = 1000*1000;
	if (/M$/.test(this.lines)) multiplier = 1024*1024;
	if (/GB$/.test(this.lines)) multiplier = 1000*1000*1000;
	if (/G$/.test(this.lines)) multiplier = 1024*1024*1024;
	//TODO: implement T/P/E/Z/Y ?

	//remove multiplier
	this.lines = this.lines.replace(/(b|kB|K|MB|M|GB|G)$/, "");

	//see: http://pubs.opengroup.org/onlinepubs/009695399/utilities/tail.html
	// if the number of lines "-n X" starts with "-" or no sign,
	//   the number of lines is relative to the end of the file.
	// if the number of lines "-n X" starts with "+",
	//   the number of lines is relative to the start of the file.
	var relative_to = -1 ; // default: negative => end of file
	if (/^[ \t]*\+/.test(this.lines))
		relative_to = 1; // positive => start of file
	//discard any +/- characters
	this.lines = this.lines.replace(/^[ \t]*[\-\+]/,"");

	if (!IsStrictDecimalIntegerValue(this.lines))
		this.error_invalid_argument(this.lines + ": invalid number of lines");

	this.lines = parseInt(this.lines) * multiplier * relative_to ;
}


ProgramTail.prototype.tail_content=function(content) {

	if (this.lines>0) {
		//positive number: relative to start of file
		//  tail -n +N    =>   skip N lines

		//not enough lines... print nothing
		if (content.length < this.lines)
			return ;
		content = content.slice(this.lines-1);
	} else {
		//negative number: relative to end of file
		//  tail -n N    => show last N lines
		content = content.slice(this.lines);
	}
	this.runtime.stdout.put_lines(content);
}

ProgramTail.prototype.tail_stdin=function() {
	if (this.verbose)
		this.runtime.stdout.put_line("==> standard input <==");
	if (this.lines===0)
		return ;
	var content = this.runtime.stdin.get_all_lines();
	this.tail_content(content);
}

ProgramTail.prototype.tail_file=function(filename) {
	var fl = {} ;
	try {
		fl = this.runtime.FS().openfile(filename,false);
	} catch (e) {
		if (IsFilesystemException(e)) {
			this.exit_error(e.toString());
		} else {
			throw e;
		}
	}

	if (this.verbose)
		this.runtime.stdout.put_line("==> " + filename + " <==");
	if (this.lines===0)
		return ;
	var content = fl.get_all_lines();
	this.tail_content(content);
}

ProgramTail.prototype.internal_run=function() {
	this.parse_command_line();

	for( var i in this.files ) {
		var filename = this.files[i];
		if (filename === "-")
			this.tail_stdin();
		else
			this.tail_file(filename);
	}

	return 0;
}

module.exports = {
	"ProgramTail" : ProgramTail
};
