/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX 'ls' utility:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/ls.html
*/

/*
A Naive implementation of ls(1)

TODO:
Fix interaction between '-l' '-lt' and -[uc]
*/
"use strict";

var ob_utils = require('utils/object_utils');
var path_utils = require('utils/path_utils');
var sprintf = require('utils/sprintf');
var strftime = require('utils/strftime');
var PosixGetOpt = require('utils/posix-getopt');
var ProgramBase = require('programs/program_base');
var Filesystem = require('os/filesystem');

module.exports = ProgramLS;

function ProgramLS() {
	this.name = "ProgramLS";
	this.program_name = "ls";
	this.files = [] ; //input file names
	this.opt_all = false ; //-a
	this.opt_almost_all = false; // -A
	this.opt_directory = false; // -d
	this.opt_g_no_owner = false; // -g
	this.opt_human_readable = false; //-h
	this.opt_long = false; // -l
	this.opt_o_no_group = false; // -o
	this.opt_reverse = false ; // -r
	this.show_time = 'mtime' ;
	this.sort_by = "name";
	this.multiple_items = false; //true if multiple files/dirs were given on the command line.
	this.files = [] ;
	this.directories = [] ;

	this.collected_files = [] ;
}

ProgramLS.prototype = new ProgramBase();
ProgramLS.prototype.constructor = ProgramLS;

ProgramLS.prototype.parse_command_line=function() {
	var parser = new PosixGetOpt(
				'a(all)A(almost-all)' +
				'c' +
				'd(directory)' +
				'gG' +
				'h(human-readable)' +
				'l' +
				'o' +
				'r(reverse)' +
				'S' +
				't' +
				'u' +
				'U' +
				'1Cxw:(width)' +
				'\u1000(help)\u1001(version)',
				this.argv);


	var option;
	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
			case 'a':
				this.opt_all = true;
				break;
			case 'A':
				this.opt_almost_all = true;
				break;

			case 'c':
				this.sort_by = 'ctime';
				this.show_time = 'ctime' ;
				break;

			case 'd':
				this.opt_directory = true;
				break;

			case 'G':
				this.opt_g_no_owner = true;
				break;

			case 'g':
				this.opt_g_no_owner = true;
				this.opt_long = true;
				break;

			case 'h':
				this.opt_human_readable = true;
				break;

			case 'l':
				this.opt_long = true;
				break;

			case 'o':
				this.opt_o_no_group = true;
				this.opt_long = true;
				break;

			case 'r':
				this.opt_reverse = true;
				break;

			case 'S':
				this.sort_by = 'size';
				break;

			case 't':
				this.sort_by = 'mtime';
				break;

			case 'u':
				this.sort_by = 'atime';
				break;

			case 'U':
				this.sort_by = 'none';
				break;

			case '1':
			case 'x':
			case 'C':
			case 'w':
				//Silently ignore layout options.
				//currently we always output one item per line.
				break;

			case '\u1000':
				this.show_help();
				this.exit(0);

			case '\u1001':
				this.show_version();
				this.exit(0);

			default:
				this.runtime.stderr.put_line("Agnostic Emulation Note: GNU ls supports many more options (invalid options here might be valid in GNU ls)");
				this.error_invalid_argument(option.errmsg);
		}
	}

	// Get first/increment/last parameters
	var args = this.argv.slice(parser.optind());

	// If no files are given, process "current directory"
	if (args.length === 0)
		args.push(".");
	this.files = args ;
	this.multiple_items = (this.files>1);
}

ProgramLS.prototype.ls_directory = function(directory)
{
	//TODO: 'readdir' currently returns absolute path. Fix it.
	var entries = this.runtime.getFS().readdir(directory);

	this.collected_files = [ ] ;

	for (var i in entries) {
		var filename = entries[i];
		var abs_path = directory + '/' + filename;

		var f ;

		//TODO:
		// Fix this terrible implementation (were 'open' function
		// is different for files and directories).
		if ( this.runtime.getFS().is_directory(abs_path) ) {
			if ( this.opt_directory )
				this.directories.push ( abs_path );

			f = this.runtime.getFS().opendir(abs_path) ;
		} else {
			f = this.runtime.getFS().openfile(abs_path) ;
		}

		var s = f.stat();
		s.filename = filename;
		this.collected_files.push(s);
	}

	//If multiple files/directories were given on the command line,
	//print the directory name
	if (this.multiple_items)
		this.runtime.stdout.put_line(directory + ":");

	//TOOD: calculate the 'total' size occupied in the directory.
	if (this.opt_long)
		this.runtime.stdout.put_line('total: 0');

	this.print_collected_files();
}

ProgramLS.prototype.print_collected_files=function() {
	var fls = this.collected_files;

	switch ( this.sort_by )
	{
	case "size":
		fls.sort( function(a,b) { a.size - b.size } ) ;
		break;
	case "mtime":
		fls.sort( function(a,b) { a.mtime - b.mtime } ) ;
		break;
	case "ctime":
		fls.sort( function(a,b) { a.cmtime - b.ctime } ) ;
		break;
	case "atime":
		fls.sort( function(a,b) { a.amtime - b.atime } ) ;
		break;
	case "name":
		fls.sort( function(a,b) {
			(a.filename < b.filename) ? -1 :
				(
				   (a.filename > b.filename) ? 1 : 0
				)
		} ) ;
		break;
	case "none":
		break;
	}

	// Short output - one file per line (columns are not supported yet)
	if (! this.opt_long ) {
		for (var i in fls)
			this.runtime.stdout.put_line(fls[i].filename);
		return ;
	}

	var six_months_ago = this.runtime.getOS().time() -
				6 * 30 * 24 * 60 * 60;

	var size_width = 0 ;

	// Iterate over the files, find the widest size
	for (var i in fls) {
		var st = fls[i]; //stat structure
		var size_str = st.size ; //TODO: support human-size
		if (size_str.toString().length > size_width)
			size_width = size_str.toString().length;
	}
	var size_format = "%" + (size_width) + 's'; // printf-style format string

	// Long output
	for (var i in fls) {
		var st = fls[i]; //stat structure
		var show_date  = st[this.show_time]; // mtime/atime/ctime
		var type_str   = path_utils.filetype_to_string(st.object_type);
		var mode_str   = path_utils.filemode_to_string(st.mode);
		var owner_str  = 'user';
		var group_str  = 'group';
		var num_links = 1 ;
		var size_str = sprintf.sprintf(size_format, st.size); //TODO: support human-size
		var date_format = (show_date > six_months_ago) ? "%b %e %H:%M" : "%b %e %Y";
		var date_str = strftime(date_format, new Date(show_date * 1000) );
		var filename_str = st.filename;

		var line = type_str + mode_str + ' ' +
			   num_links.toString() + ' ';

		if (! this.opt_g_no_owner )
			line += owner_str + ' ';
		if (! this.opt_o_no_group )
			line += group_str + ' ';

		line += size_str + ' ' +
			date_str + ' ' +
			filename_str ;

		this.runtime.stdout.put_line(line);
	}
}


ProgramLS.prototype.internal_run=function() {
	this.parse_command_line();

	/* Step 1:
        Iterate over all the files/directories explicitly speicifed on the command line.
	If it's a regular file - collect and print it first.
	If it's a directory - add it to the list of directories to be processed in step 2.
	*/
	for (var i in this.files) {
		var filename = this.files[i];
		filename = path_utils.resolve ( this.runtime.getcwd(), filename ) ;

		if (! this.runtime.getFS().path_exists(filename) ) {
			//TODO: instead of exiting, return exit code 1 later.
			this.exit_error("cannot access " + filename + ": no such file or directory");
		}
		if ( this.runtime.getFS().is_directory(filename) ) {
			this.directories.push(filename);
		} else {
			var f = this.runtime.getFS().openfile(filename) ;
			var s = f.stat();
			s.filename = filename;
			this.collected_files.push(s);
		}
	}
	this.print_collected_files();


	/*
	Step 2: iterate each directory and print it's content.
	NOTE: if we're doing recursive printing, the 'directories' array
	      might be modified with more directoies - so use 'while'.
	*/
	while ( this.directories.length > 0 ) {
		var directory = this.directories.shift();
		this.ls_directory ( directory ) ;
	}

	return 0;
}
