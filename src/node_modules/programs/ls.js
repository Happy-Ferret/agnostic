/*
   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX 'ls' utility:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/ls.html
*/

/*
A Naive implementation of ls(1)

TODO:
Fix interaction between '-l' '-lt' and -[uc]
*/
"use strict";

var ob_utils = require('utils/object_utils');
var sprintf = require('utils/sprintf');
var strftime = require('utils/strftime');
var PosixGetOpt = require('utils/posix-getopt');
var ProgramBase = require('programs/program_base');
var Filesystem = require('os/filesystem');

module.exports = ProgramLS;

function ProgramLS() {
	this.name = "ProgramLS";
	this.program_name = "ls";
	this.files = [] ; //input file names
	this.opt_all = false ; //-a
	this.opt_almost_all = false; // -A
	this.opt_directory = false; // -d
	this.opt_g_no_owner = false; // -g
	this.opt_human_readable = false; //-h
	this.opt_long = false; // -l
	this.opt_o_no_group = false; // -o
	this.opt_reverse = false ; // -r
	this.show_time = 'mtime' ;
	this.sort_by = "name";
	this.files = [] ;

	this.collected_files = [] ;
}

ProgramLS.prototype = new ProgramBase();
ProgramLS.prototype.constructor = ProgramLS;

ProgramLS.prototype.parse_command_line=function() {
	var parser = new PosixGetOpt(
				'a(all)A(almost-all)' +
				'c' +
				'd(directory)' +
				'g' +
				'h(human-readable)' +
				'l' +
				'o' +
				'r(reverse)' +
				'S' +
				't' +
				'u' +
				'U' +
				'1Cxw:(width)' +
				'\u1000(help)\u1001(version)',
				this.argv);


	var option;
	while ((option = parser.getopt()) !== undefined) {
		switch (option.option) {
			case 'a':
				this.opt_all = true;
				break;
			case 'A':
				this.opt_almost_all = true;
				break;

			case 'c':
				this.sort_by = 'ctime';
				this.show_time = 'ctime' ;
				break;

			case 'd':
				this.opt_directory = true;
				break;

			case 'g':
				this.opt_g_no_owner = true;
				break;

			case 'h':
				this.opt_human_readable = true;
				break;

			case 'l':
				this.opt_long = true;
				break;

			case 'o':
				this.opt_o_no_group = true;
				break;

			case 'r':
				this.opt_reverse = true;
				break;

			case 'S':
				this.sort_by = 'size';
				break;

			case 't':
				this.sort_by = 'mtime';
				break;

			case 'u':
				this.sort_by = 'atime';
				break;

			case 'U':
				this.sort_by = 'none';
				break;

			case '1':
			case 'x':
			case 'C':
			case 'w':
				//Silently ignore layout options.
				//currently we always output one item per line.
				break;

			case '\u1000':
				this.show_help();
				this.exit(0);

			case '\u1001':
				this.show_version();
				this.exit(0);

			default:
				this.runtime.stderr.put_line("Agnostic Emulation Note: GNU ls supports many more options (invalid options here might be valid in GNU ls)");
				this.error_invalid_argument(option.errmsg);
		}
	}

	// Get first/increment/last parameters
	var args = this.argv.slice(parser.optind());

	// If no files are given, process "current directory"
	if (args.length === 0)
		args.push(".");
	this.files = args ;

	// Default for multiple files is showing file names,
	// unless quiet/verbose is explicitly specified
	if ( (args.length>1) && !this.quiet && !this.verbose )
		this.verbose = true;
}

ProgramLS.prototype.ls_directory = function(filename)
{
	throw "not implemented yet";
}

ProgramLS.prototype.ls_file = function(filename)
{
	if (! this.runtime.getFS().path_exists(filename) ) {
		this.exit_error("cannot access " + filename + ": no such file or directory");
	}
	//TODO: stop recursion after one level, unless opt_R
	if ( !this.opt_directory && this.runtime.getFS().is_directory(filename) ) {
		this.ls_directory(filename);
		return;
	}

	var f = this.runtime.getFS().openfile(filename) ;
	var s = f.stat();
	s.filename = filename;
	this.collected_files.push(s);
}

ProgramLS.prototype.print_collected_files=function() {
	var fls = this.collected_files;

	switch ( this.sort_by )
	{
	case "size":
		fls.sort( function(a,b) { a.size - b.size } ) ;
		break;
	case "mtime":
		fls.sort( function(a,b) { a.mtime - b.mtime } ) ;
		break;
	case "ctime":
		fls.sort( function(a,b) { a.cmtime - b.ctime } ) ;
		break;
	case "atime":
		fls.sort( function(a,b) { a.amtime - b.atime } ) ;
		break;
	case "name":
		fls.sort( function(a,b) {
			(a.filename < b.filename) ? -1 :
				(
				   (a.filename > b.filename) ? 1 : 0
				)
		} ) ;
		break;
	case "none":
		break;
	}

	// Short output - one file per line (columns are not supported yet)
	if (! this.opt_long ) {
		for (var i in fls)
			this.runtime.stdout.put_line(fls[i].filename);
		return ;
	}

	var six_months_ago = this.runtime.getOS().time() -
				6 * 30 * 24 * 60 * 60;

	// Long output
	for (var i in fls) {
		var st = fls[i]; //stat structure
		var show_date = st[this.show_time]; // mtime/atime/ctime
		var date_format = (show_date > six_months_ago) ? "%b %e %H:%M" : "%b %e %Y";
		var date_str = strftime(date_format, new Date(show_date * 1000) );
	}
}


ProgramLS.prototype.internal_run=function() {
	this.parse_command_line();

	for (var i in this.files)
		this.ls_file ( this.files[i] ) ;

	this.print_collected_files();

	return 0;
}
