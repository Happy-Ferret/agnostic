/*
   POSIX-Shell compatible Execution Engine.

   This file is part of UNIX Guide for the Perplexed project.
   Copyright (C) 2014 by Assaf Gordon <assafgordon@gmail.com>
   Released under GPLv3 or later, with the following addition:

     As additional permission under GNU GPL version 3 section 7, you
     may distribute non-source (e.g., minimized or compacted) forms of
     that code without the copy of the GNU GPL normally required by
     section 4, provided you include this license notice and a URL
     through which recipients can access the Corresponding Source.

   See: https://www.gnu.org/philosophy/javascript-trap.html

   POSIX Shell Command Language Standard:
   http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html
*/

/* This module executes a shell syntax tree, as generated by 'posix_shell.poegjs' . */

shell_executor = (function() {
	var my = {} ;

	var loggers = [];


	function AddLogger(l)
	{
		loggers.push(l);
	}

	/* Log Dispatcher, used through-out the SHELL executor module.
	   The first parameter is taken to be a topic name
	   (think of topic as "sub-source" poor-man's hierarchy).
	   All other parameters are passed to the actual logging function.

	   NOTE: the logging function might treat parameters with special indicators.
	   Examples:
		A parameter surrounded by back-ticks is taken to be a filename/command,
		and might be rendered in fixed-font.
	*/
	function shlog()
	{
		var source = "SHELL";
		if (arguments.length<2)
			throw "Internal error: log requires two-or-more parameters";
		var args = Array.prototype.slice.call(arguments);
		var topic = args[0];
		var params = args.slice(1);

		for (var i in loggers) {
			loggers[i].log( { "source" : source, "topic" : topic, "params" : params } ) ;
		}
	}
	function shlog_indent()
	{
		for (var i in loggers) {
			loggers[i].indent();
		}
	}
	function shlog_exdent()
	{
		for (var i in loggers) {
			loggers[i].exdent();
		}
	}

	function ShellExecutorException(message,data) {
		this.message = message ;
		this.name = "ShellExecutorException";
		this.data = data ;
		this.toString = function() {
			if (data)
				return this.name + ": " + message + " (data = " +
					JSON.stringify(data) + ")";
			return this.name + ": " + message;
		}
	}

	/* TODO: IsObject and IsArray are limited (perhaps even incorrect),
	   according to http://tobyho.com/2011/01/28/checking-types-in-javascript/ */

	/* A Helper function, returns true of the given parameter is an object */
	function IsObject(obj) {
		var s = Object.prototype.toString.call(obj);
		return (  s === "[object Object]");
	}
	function VerifyObject(obj) {
		if (!IsObject(obj))
			throw new ShellExecutorException("'obj' is not a valid object", obj);
	}
	/* A Helper function, returns true of the given parameter is an array */
	function IsArray(obj) {
		var s = Object.prototype.toString.call(obj);
		return (  s === "[object Array]");
	}
	function VerifyArray(obj) {
		if (!IsArray(obj))
			throw new ShellExecutorException("'obj' is not a valid array", obj);
	}

	/* A Helper function to verify that a given object has only the allowed keys.
	   The function throws 'ShellExecutorException' if it finds a disallowed key.

	   Example:
		a = { "foo" : "bar", "baz" : [1,2,3,4,5] };
		VerifyAllowedKeys(a, ["foo","baz"]); //Will succeed
		VerifyAllowedKeys(a, ["foo"]); //Will throw exception: "baz" is not an allowed key
	*/
	function VerifyAllowedKeys(obj, allowed_keys_array) {
		VerifyObject(obj);

		/* Create a hash of allowed keys */
		var allowed_keys = {};
		for (var i in allowed_keys_array) {
			allowed_keys[allowed_keys_array[i]] = 1 ;
		}

		/* Iterate over keys in obj */
		for (var key in obj) {
			var ok = (key in allowed_keys);
			if (! (key in allowed_keys) )
				throw new ShellExecutorException(
					":'obj' contains disallowed key '" + key + "'" +
					" allowed-keys = '" + allowed_keys_array.toString() + "'" ,obj);
		}
	}

	/* A Helper function to verify a hash contains just one key.
	   The function throws if there are ZERO keys, or two-or-more keys.

	   Example:
		VerifyOneKey( { "foo": [1,2,3,4] } ); // OK
		VerifyOneKey( { } ) ; // throws
		VerifyOneKey( { "foo" : 4, "bar": 43 } ) ; //throws
	*/
	function VerifyOneKey(obj) {
		VerifyObject(obj);

		if (Object.keys(obj).length==0)
			throw new ShellExecutorException("'obj' is empty", obj);
		if (Object.keys(obj).length>1)
			throw new ShellExecutorException("'obj' contains more than one key", obj);
	}

	/* A Helper function to return the name of the one key in an object.
	   The function will throw if the objecct doesn't have keys, or have more
	   than more key.

	   Example:
		GetOneKey( { "foo" : [1,2,3,4] } ); //returns "foo"
		GetOneKey( { } ); //throws
		GetOneKey( { "foo": 3, "bar": [1,2,3,4] } ); //throws.
	*/
	function GetOneKey(obj) {
		VerifyOneKey(obj);
		for (var key in obj) {
			return key;
		}
	}

	/* A Helper function to verify the structure of a redirection object */
	function VerifyRedirectionObject(obj) {
		VerifyAllowedKeys(obj, ["filedescriptor","forceclobber","filename","type"]);

		if ( ! ( "type" in obj ) )
			throw new ShellExecutorException(
				"redirection object doesn't have 'type' key", obj);
		var redir_type = obj["type"];

		var allowed_types = {
			"input_file":1,
			"output_file":1,
			"append_file":1,
			"input_dup_fd":1,
			"output_dup_fd":1,
			"inout_file":1 };

		if ( ! (redir_type in allowed_types ) )
			throw new ShellExecutorException("redirection object jas invalid type '"+type+"'",obj);

		if ( ! ( "filename" in obj ) )
			throw new ShellExecutorException(
				"redirection object doesn't have 'filename' key", obj);
		if ( ! ( "filedescriptor" in obj ) )
			throw new ShellExecutorException(
				"redirection object doesn't have 'filedesciptor' key", obj);
	}

	/************************************************************
	  The "DescribeXXXXX" functions take a shell-parse tree and recursively
	  iterate it, and return a single-line string representing the shell command.
	  TODO: make this OO
	************************************************************/
	function DescribeAssignments(obj)
	{
		VerifyArray(obj);
		var desc = "" ;
		for (var i in obj) {
			var varname = GetOneKey(obj[i]);
			var value   = obj[i][varname];
			if (desc !== "")
				desc = desc + " ";
			desc = desc + varname + "=" + value ;
		}
		return desc;
	}

	function DescribeRedirections(obj)
	{
		//TODO: generate descriptive string from redirection structure
		return "";
	}

	function DescribeCommandTokens(obj)
	{
		VerifyArray(obj);
		return obj.join(" ");
	}

	function DescribeSimpleCommand(obj)
	{
		var cmd = obj["SimpleCommand"];
		VerifyAllowedKeys(cmd, ["tokens","redirections","assignments"]);

		var assignment_desc = "" ;
		var tokens_desc = "" ;
		var redirection_desc = "" ;
		if ("assignments" in cmd)
			assignment_desc = DescribeAssignments( cmd["assignments"] ) + " " ;
		if ("redirections" in cmd)
			redirection_desc = " " + DescribeRedirections( cmd["redirections"] );
		if ("tokens" in cmd)
			tokens_desc = DescribeCommandTokens( cmd["tokens"] );

		return assignment_desc + tokens_desc + redirection_desc ;
	}

	function DescribeAndOrList(obj)
	{
		var list = obj["and_or_list"];
		VerifyArray(list);
		var cmd = list[0];
		var list_desc = DescribeCommand(cmd);
		var i = 1 ;
		while (i<list.length) {
			var condition = list[i];
			var cmd = list[i+1];
			i += 2;
			list_desc = list_desc + " " + condition + " " + DescribeCommand(cmd);
		}
		return list_desc;
	}

	function DescribePipeline(obj)
	{
		var pipeline = obj["pipeline"];
		VerifyArray(pipeline);
		var pipe_desc = pipeline.map(DescribeCommand).join(" | ");
		return pipe_desc ;
	}


	function DescribeCommand(obj)
	{
		VerifyAllowedKeys(obj, ["SimpleCommand","and_or_list","list","pipeline"]);
		if ( "SimpleCommand" in obj )
			return DescribeSimpleCommand(obj)
		else if ( "and_or_list" in obj )
			return DescribeAndOrList(obj)
		else if ( "list" in obj )
			return DescribeList(obj)
		else if ( "pipeline" in obj )
			return DescribePipeline(obj)
	}

	/* Process Assignments (e.g. "FOO=BAR").
	   Example: for the command 'CC=clang CXX=clang++ make',
	   The expected 'obj' is an array containing:
	    [
	      { "CC": "clang" },
	      { "CXX": "clang++" }
	    ]
	*/
	function ProcessAssignments(obj)
	{
		VerifyArray(obj);
		for (var i in obj) {
			var varname = GetOneKey(obj[i]);
			var value   = obj[i][varname];

			//TODO: variable expansion on 'value'
			shlog("Environment Variables", varname + "=" + value ) ;
		}
	}


	/* Process Redirections - Before command execution.
	   Input redirections are processed BEFORE the command is executed.
	   Output redirection messages are shown to the user before execution starts. */
	function ProcessPreexecuteRedirections(obj)
	{
		VerifyArray(obj);
		for (var i in obj) {
			var redir = obj[i];
			VerifyRedirectionObject(redir);

			var redir_type     = redir["type"];
			var redir_fd       = redir["filedescriptor"];
			var redir_filename = redir["filename"];

			if (redir_type == "input_file") {
				if (redir_fd==0) { //STDIN
					shlog("Redirection",
						"Input(STDIN) from file", "`" + redir["filename"] + "`");
				} else {
					shlog("Redirection",
						"unsupported feature: input redirection to a specific file-descriptor");
				}
			}
			else if (redir_type == "input_dup_fd") {
				shlog("Redirection",
					"unsupported feature: duplicated input File-Descriptor");
			}
			else if (redir_type == "inout_file") {
				shlog("Redirection",
					"unsupported feature: input+output redirection");
			}
			else if (redir_type == "output_file") {
				if (redir_fd==1) { //STDOUT
					shlog("Redirection",
						"Output(STDOUT) to file","`" + redir["filename"] + "`");
				} else if (redir_fd==2) { //STDERR
					shlog("Redirection",
						"Error(STDERR) to file","`" + redir["filename"] + "`");
				} else {
					shlog("Redirection","unsupported feature: output redirection from a specific file-descriptor");
				}
			}
			else if (redir_type == "append_file") {
				if (redir_fd==1) { //STDOUT
					shlog("Redirection","Output(STDOUT) Redirection, appending to file", "'" + redir["filename"] + "'");
				} else if (redir_fd==2) { //STDERR
					shlog("Redirection","Error(STDERR) Redirection, appending to file","'" + redir["filename"] + "'");
				} else {
					shlog("Redirection","unsupported feature: output redirection from a specific file-descriptor");
				}
			}
			else if (redir_type == "output_dup_fd") {
				if ( redir_fd==1 && redir_filename ==="2" ) { // STDOUT-to-STDERR
					shlog("Redirection", "Redirecting STDOUT to STDERR");
				} else if ( redir_fd==2 && redir_filename ==="1" ) { // STDERR-to-STDER
					shlog("Redirection", "Redirecting STDOUT to STDERR");
				} else {
					shlog("Redirection","unsupported feature: File-Descriptor redirection (except STDOUT/STDER)");
				}
			}
			else if (redir_type == "inout_file") {
				shlog("Redirection","unsupported feature: input+output redirection");
			}
		}
	}

	/* Process Redirections - after the command was execited.
	   Unlike real shell - output redirections are processed AFTER the
	   command is executed (the command will return STDOUT/STDERR in a string,
	   This function will redirect the string accordingly. */
	function ProcessPostexecuteRedirections(obj)
	{
		VerifyArray(obj);
		for (var i in obj) {
			var redir = obj[i];
			VerifyRedirectionObject(redir);

			var redir_type     = redir["type"];
			var redir_fd       = redir["filedescriptor"];
			var redir_filename = redir["filename"];
		}
	}

	/* Process the tokens of the command to be executed */
	function ProcessCommandTokens(obj)
	{
		VerifyArray(obj);

		var cmdname = obj[0];
		var parameters = obj.slice(1);

		var param_desc = "";
		if (parameters.length>0) {
			param_desc = "with parameters: " + parameters.toString();
		}

		if (cmdname.indexOf("/") !== -1) {
			//If the first token contains a slash character,
			//it is assumed to be a relative/full path of a command.
			//see "2.9.1 Simple Commands", subsection "Commad Search and Execution", item #2.
			shlog("Command", "executing program", "'" + cmdname + "'",  param_desc);
		} else {
			//TODO: Check if cmdname matches a special built-in utility
			//TODO: Check if cmdname matches a known shell function
			//TODO: check if cmdname matches known intername command (e.g. alias)

			//Otherwise, search 'cmdname' in PATH
			shlog("Command", "searching for program", "`" + cmdname + "`","in the $PATH");
			shlog("Command", "executing program","`" + cmdname + "`", param_desc);
		}

		shlog("Command", "TODO: implement Javascript-Execution. For now - emulating exit code 0");

		//TODO:
		// Get STDOUT,STDERR,exitcode from program.
		var exitcode = 0 ;

		if (exitcode == 0) {
			shlog("Command", "program exited with code 0 - considerd a successful completion");
		} else {
			shlog("Command", "program exited with code " + exitcode +
				    " - non-zero code indicates an error");
		}
		return exitcode;
	}

	/* Process a "SimpleCommand" .
	   A simple command can have Assignment and Redirections. */
	function ProcessSimpleCommand(obj)
	{
		var cmd = obj["SimpleCommand"];

		VerifyAllowedKeys(cmd, ["tokens","redirections","assignments"]);

		var exitcode = 0 ;

		if ("assignments" in cmd)
			ProcessAssignments( cmd["assignments"] ) ;

		if ("redirections" in cmd)
			ProcessPreexecuteRedirections( cmd["redirections"] );

		//TODO: Quotes Removal
		//TODO: parameter expansion
		//TODO: filename expansion

		//TODO: pass STDIN to process
		if ("tokens" in cmd)
			exitcode = ProcessCommandTokens( cmd["tokens"] );
		//TODO: get STDOUT/STDERR from process
		//TODO: get exit code from process

		if ("redirection" in cmd)
			ProcessPostexecuteRedirections( cmd["redirections"] );

		return exitcode;
	}

	/* Process commands in a pipeline */
	function ProcessPipeline(obj)
	{
		var pipeline = obj["pipeline"];
		VerifyArray(pipeline);
		var exitcode = 0 ;

		shlog("Pipeline", "Found pipeline with " + pipeline.length + " steps:");
		for (var i in pipeline) {
			var cmd = pipeline[i];
			shlog("Pipeline", (parseInt(i)+1) + ". ", "`" + DescribeCommand(cmd) + "`");
		}

		for (var i in pipeline) {
			var cmd = pipeline[i];
			if (parseInt(i)>0) {
				shlog("Pipeline", "Using Output (STDOUT) from previous step as input (STDIN) of next step");
			}

			shlog("Pipeline", "running step " + ( parseInt(i)+1) + " of pipeline: ", "`" + DescribeCommand(cmd) + "`");
			exitcode = ProcessCommand(true,cmd);
			//TODO: take STDOUT of command, and pass it as STDIN for next command
		}
		shlog("Pipeline", "pipeline result: the last program exited with code " + exitcode);
		return exitcode;
	}

	/* Process commands in an And/Or list */
	function ProcessAndOrList(obj)
	{
		var list = obj["and_or_list"];
		VerifyArray(list);
		var cmd = list[0];

		shlog("AndOrList","Found AND/OR list with " + ((list.length+1)/2)+ " steps:");
		shlog("AndOrList","1. ", "`" + DescribeCommand(cmd) + "`");
		var i = 1 ;
		while (i<list.length) {
			var condition = list[i];
			var tmp = list[i+1];
			i += 2 ;
			var cond_desc = "Internel error unknown condition";
			if (condition === "&&") {
				cond_desc = "succeeds (&&)";
			} else if (condition === "||") {
				cond_desc = "fails (||)";
			}
			shlog("AndOrList", (parseInt(i/2)+1) + ". ",
				"`" + DescribeCommand(tmp) + "`", "(if previous step " + cond_desc + ")");
		}

		shlog("AndOrList", "running first step in AND/OR list: ","`" + DescribeCommand(cmd) + "`");
		exitcode = ProcessCommand(true,cmd);

		var i = 1 ;
		while (i<list.length) {
			var condition = list[i];
			var cmd = list[i+1];
			var cmd_desc = DescribeCommand(cmd);
			i += 2;
			var step_num = parseInt(i/2)+1;
			if (condition !== "&&" && condition !== "||")
				throw ShellExecutorException("Invalid condition '" + condition + "' in And/Or list", obj);

			var run_next_step =
				( (condition === "&&" && exitcode === 0) ||
				  (condition === "||" && exitcode !== 0) ) ;
			var action = (run_next_step ? "running" : "skipping" );

			shlog("AndOrList", action + " step " + step_num, "`" + cmd_desc + "`",
						": previous exit code was " + exitcode +
						" and condition was " + condition ) ;
			if (run_next_step) {
				exitcode = ProcessCommand(true,cmd);
			}
		}
		shlog("AndOrList", "Final result: the last step exited with code " + exitcode);
		return exitcode;
	}

	/* Process commands in a Foreground/Background list */
	function ProcessList(obj)
	{
		var list = obj["list"];
		VerifyArray(list);
		var cmd = list[0];
		var exitcode = 0 ;

		shlog("List", "Found Command List with " + (list.length)+ " steps:");
		for (var i in list) {
			var step = list[i];
			var step_type = GetOneKey(step);
			var step_cmd = step[step_type];
			shlog("List", (parseInt(i)+1) +". ", "`" + DescribeCommand(step_cmd) + "`",
				"- run in the " + step_type);
		}

		/* This javascript shell emulator runs everything in the foreground.
		   Background '&' operator is silently ignored.
		   TODO: does this affect correct exitcode procesing? */
		for (var i in list) {
			var step = list[i];
			var step_type = GetOneKey(step);
			var step_cmd = step[step_type];
			shlog("List", "Running step " + (parseInt(i)+1) +":", "`" + DescribeCommand(step_cmd) + "`");
			exitcode = ProcessCommand(true,step_cmd);
		}

		shlog("List", "Final result: the last step exited with code " + exitcode);
		return exitcode;
	}

	/* The main dispatcher, based on the content of 'obj' */
	function ProcessCommand(indent,obj)
	{
		/* Verify obj is indeed an object */
		VerifyAllowedKeys(obj, ["SimpleCommand","and_or_list","list","pipeline"]);

		var exitcode = 1 ;

		if (indent)
			shlog_indent();

		if ( "SimpleCommand" in obj )
			exitcode = ProcessSimpleCommand(obj)
		else if ( "and_or_list" in obj )
			exitcode = ProcessAndOrList(obj)
		else if ( "list" in obj )
			exitcode = ProcessList(obj)
		else if ( "pipeline" in obj )
			exitcode = ProcessPipeline(obj)
		else
			throw new ShellExecutorException("Internal Error: Unrecognized key in 'obj'", obj);

		if (indent)
			shlog_exdent();

		return exitcode;
	}

	function ShellExecute(obj) {
		return ProcessCommand(false,obj);
	}

	return {
		"ShellExecute": ShellExecute,
		"DescribeCommand": DescribeCommand,
		"AddLogger" : AddLogger,
		/* These are exported in a sub-namespace, for testing purposes */
		"HelperFunctions" : {
				"IsObject": IsObject,
				"VerifyObject" : VerifyObject,
				"IsArray": IsArray,
				"VerifyArray" : VerifyArray,
				"VerifyAllowedKeys" : VerifyAllowedKeys,
				"VerifyOneKey" : VerifyOneKey,
				"GetOneKey" : GetOneKey
			}
	};
})();
